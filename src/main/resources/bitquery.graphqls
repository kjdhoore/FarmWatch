# Blockchain address
type Address {
  # String address representation
  address: String!

  # Annotations ( tags ), if exists
  annotation: String
}

# Address selector
input AddressSelector {
  # Equal to Address
  is: String

  # Not Equal to Address
  not: String

  # In the list of Addresses
  in: String

  # Not in the list of Addresses
  notIn: String
}

# Address selector
input AddressSelectorIn {
  # Equal to Address
  is: String

  # In the list of Addresses
  in: String
}

# Blockchain account with address and type
type AddressWithAccount {
  # Account ID
  account: String!

  # String address representation
  address: String!

  # Annotations ( tags ), if exists
  annotation: String

  # Account type
  type: String!
}

# Algorand Blockchain
type Algorand {
  # Basic information about address ( or smart contract )
  address(address: [AlgorandAddressSelector!]!): [AlgorandAddressInfo!]!

  # Arguments of Smart Contract Calls and Events
  arguments(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txType: TxTypeSelector, txFrom: [AlgorandAddressSelector!], caller: [AlgorandAddressSelector!], reference: [AlgorandAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], smartContractAddress: [AlgorandAddressSelector!], argindex: ArgumentIndexSelector, any: [AlgorandArgumentFilter!], options: QueryOptions): [AlgorandArguments!]

  # Blockchain Blocks
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: [AlgorandAddressSelector!], blockReward: [AmountSelector!], nextProtocol: StringIdSelector, currentProtocol: StringIdSelector, any: [AlgorandBlockFilter!], options: QueryOptions): [AlgorandBlocks!]

  # Money flow using Coinpath technology
  coinpath(sender: AlgorandAddressSelector, receiver: AlgorandAddressSelector, currency: [AlgorandCurrencySelector!], initialAddress: AlgorandAddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [AlgorandCoinpath!]

  # Smart Contract Calls
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AlgorandAddressSelector!], smartContractAddress: [AlgorandAddressSelector!], txType: TxTypeSelector, any: [AlgorandSmartContractCallFilter!], options: QueryOptions): [AlgorandSmartContractCalls!]

  # Blockchain Transactions
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AlgorandAddressSelector!], txIndex: TxIndexSelector, txCurrency: [AlgorandCurrencySelector!], txType: TxTypeSelector, txSubtype: TxSubtypeSelector, any: [AlgorandTransactionFilter!], options: QueryOptions): [AlgorandTransactions!]

  # Currency Transfers
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AlgorandAddressSelector!], txIndex: TxIndexSelector, sender: [AlgorandAddressSelector!], receiver: [AlgorandAddressSelector!], currency: [AlgorandCurrencySelector!], amount: [AmountSelector!], txType: TxTypeSelector, transferType: AlgorandTransferTypeSelector, any: [AlgorandTransferFilter!], options: QueryOptions): [AlgorandTransfers!]
}

# Address detailed information for Algorand network
type AlgorandAddressInfo {
  # Address
  address: Address

  # Smart Contract if exists on the address
  smartContract: AlgorandSmartContract
}

# Algorand Address
input AlgorandAddressSelector {
  # Equal to Address
  is: String

  # Not Equal to Address
  not: String

  # In the list of Addresses
  in: [String!]

  # Not in the list of Addresses
  notIn: [String!]
}

input AlgorandArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: TxIndexSelector
  txType: TxTypeSelector
  txFrom: [AlgorandAddressSelector!]
  caller: [AlgorandAddressSelector!]
  reference: [AlgorandAddressSelector!]
  value: [ArgumentValueSelector!]
  argument: [ArgumentSelector!]
  smartContractAddress: [AlgorandAddressSelector!]
  argindex: ArgumentIndexSelector
}

# Arguments of Smart Contract Calls
type AlgorandArguments {
  any(of: AlgorandArgumentsMeasureable!): String

  # Sequential index of value in array ( multi-dimensional)
  argindex: Int!

  # Block in the blockchain
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Counts and other metrics
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txType: TxTypeSelector, txFrom: [AlgorandAddressSelector!], caller: [AlgorandAddressSelector!], reference: [AlgorandAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], smartContractAddress: [AlgorandAddressSelector!], argindex: ArgumentIndexSelector): Int

  # Calendar date
  date: Date
  firstRound: Int
  genesisHash64: String
  genesisId: String
  lastRound: Int
  maximum(of: AlgorandArgumentsMeasureable!, get: AlgorandArgumentsMeasureable): String
  minimum(of: AlgorandArgumentsMeasureable!, get: AlgorandArgumentsMeasureable): String
  note: String
  poolerror: String

  # Smart contract being called
  smartContract(smartContractAddress: [AlgorandAddressSelector!]): AlgorandSmartContract

  # Transaction where call happened
  transaction(txHash: [HashSelector!], txFrom: [AlgorandAddressSelector!]): TransactionHashIndex

  # Transaction sender
  txSender(txSender: [AlgorandAddressSelector!]): Address

  # Transaction type in which the transfer happened
  txType(txType: [AlgorandTxType!]): AlgorandTxType

  # The Value of argument
  value(value: [ArgumentValueSelector!]): String
}

enum AlgorandArgumentsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Transaction type
  tx_type

  # Transaction Sender
  tx_sender

  # Smart Contract
  smart_contract

  # Argument value
  argument_value

  # Argument index
  argument_index
}

input AlgorandBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  proposer: [AlgorandAddressSelector!]
  blockReward: [AmountSelector!]
  nextProtocol: StringIdSelector
  currentProtocol: StringIdSelector
}

# Blocks in Algorand blockchain
type AlgorandBlocks {
  any(of: AlgorandBlocksMeasureable!): String
  count(uniq: AlgorandBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: [AlgorandAddressSelector!], blockReward: [AmountSelector!], nextProtocol: StringIdSelector, currentProtocol: StringIdSelector): Int
  currentProtocol: String

  # Calendar date
  date: Date
  frac: BigInt!

  # Block hash
  hash(blockHash: [HashSelector!]): String!

  # Block number (height) in blockchain
  height(height: BlockSelector): Int!
  maximum(of: AlgorandBlocksMeasureable!, get: AlgorandBlocksMeasureable): String
  minimum(of: AlgorandBlocksMeasureable!, get: AlgorandBlocksMeasureable): String
  nextProtocol: String
  nextProtocolApprovals: BigInt
  nextProtocolSwitchOn: BigInt
  nextProtocolVoteBefore: BigInt

  # Previous block hash
  previousBlockHash: String!

  # Block proposer
  proposer(proposer: [AlgorandAddressSelector!]): Address
  rate(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: [AlgorandAddressSelector!], blockReward: [AmountSelector!], nextProtocol: StringIdSelector, currentProtocol: StringIdSelector): Float
  reward(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: [AlgorandAddressSelector!], blockReward: [AmountSelector!], nextProtocol: StringIdSelector, currentProtocol: StringIdSelector): Float
  seed: String

  # Block timestamp
  timestamp(time: DateTimeSelector): DateTime
  txnRoot: String!
  upgradeApprove: Int
  upgradePropose: String
}

enum AlgorandBlocksMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Block hash
  block_hash

  # Block Reward
  block_reward

  # Block Proposer
  proposer

  # Next protocol approvals
  next_protocol_approvals
}

enum AlgorandBlocksUniq {
  # Unique proposer count
  proposers

  # Unique date count
  dates
}

enum AlgorandCallsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Transaction type
  tx_type

  # Transaction Sender
  tx_sender

  # Smart Contract
  smart_contract
}

# Coinpath
type AlgorandCoinpath {
  # Summary of transfered value
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  # Block where transaction is included
  block: Block

  # Count of transfers
  count: Int

  # Currency of transfer
  currency: Currency

  # 1-based hop depth of the graph
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  # Receiver address
  receiver: Address

  # Sender address
  sender: Address

  # Transaction of transfer happened
  transaction: TransactionHashValue
}

# Currency selector in Algorand blockchain.
#   Currency is selected by asset ID. To select ALGO use ID=0
input AlgorandCurrencySelector {
  # Currency is
  is: Int

  # Currency not
  not: Int

  # Currency in the list
  in: [Int!]

  # Currency not in the list
  notIn: [Int!]
}

enum AlgorandNetwork {
  # Algorand Mainnet (ALGO)
  algorand

  # Algorand Testnet
  algorand_testnet

  # Algorand Betanet
  algorand_betanet
}

# Algorand smart contract
type AlgorandSmartContract {
  # Smart Contract Address
  address: Address!

  # Smart Contract byte code
  bytecode: String

  # Smart Contract Deassembled source code
  source: String
}

input AlgorandSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: TxIndexSelector
  txSender: [AlgorandAddressSelector!]
  smartContractAddress: [AlgorandAddressSelector!]
  txType: TxTypeSelector
}

# Smart Contract Calls
type AlgorandSmartContractCalls {
  any(of: AlgorandCallsMeasureable!): String

  # Block in the blockchain
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Counts and other metrics
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AlgorandAddressSelector!], smartContractAddress: [AlgorandAddressSelector!], txType: TxTypeSelector): Int

  # Calendar date
  date: Date

  # Fee used in transaction call
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AlgorandAddressSelector!], smartContractAddress: [AlgorandAddressSelector!], txType: TxTypeSelector): Float
  firstRound: Int
  genesisHash64: String
  genesisId: String
  lastRound: Int
  maximum(of: AlgorandCallsMeasureable!, get: AlgorandCallsMeasureable): String
  minimum(of: AlgorandCallsMeasureable!, get: AlgorandCallsMeasureable): String
  note: String
  poolerror: String

  # Smart contract being called
  smartContract(smartContractAddress: [AlgorandAddressSelector!]): AlgorandSmartContract

  # Transaction where call happened
  transaction(txHash: [HashSelector!], txFrom: [AlgorandAddressSelector!]): TransactionHashIndex

  # Transaction sender
  txSender(txSender: [AlgorandAddressSelector!]): Address

  # Transaction type in which the transfer happened
  txType(txType: [AlgorandTxType!]): AlgorandTxType
}

input AlgorandTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [AlgorandAddressSelector!]
  txIndex: TxIndexSelector
  txCurrency: [AlgorandCurrencySelector!]
  txType: TxTypeSelector
  txSubtype: TxSubtypeSelector
}

# Transactions in Algorand blockchain
type AlgorandTransactions {
  any(of: AlgorandTransactionsMeasureable!): String

  # Block where transfer transaction is included
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: AlgorandTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AlgorandAddressSelector!], txIndex: TxIndexSelector, txCurrency: [AlgorandCurrencySelector!], txType: TxTypeSelector, txSubtype: TxSubtypeSelector): Int

  # Asset related to transaction
  currency(txCurrency: [AlgorandCurrencySelector!]): Currency

  # Calendar date
  date: Date
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AlgorandAddressSelector!], txIndex: TxIndexSelector, txCurrency: [AlgorandCurrencySelector!], txType: TxTypeSelector, txSubtype: TxSubtypeSelector): Float
  firstRound: Int
  genesisHash: String
  genesisId: String

  # Hash hex representation
  hash(txHash: [HashSelector!]): String!

  # Transaction index in block, 0 based
  index(txIndex: [TxIndexSelector!]): Int
  lastRound: Int
  maximum(of: AlgorandTransactionsMeasureable!, get: AlgorandTransactionsMeasureable): String
  minimum(of: AlgorandTransactionsMeasureable!, get: AlgorandTransactionsMeasureable): String
  note: String
  poolerror: String

  # Transaction sender
  sender(txSender: [AlgorandAddressSelector!]): Address

  # Transaction sub type
  subtype(txType: TxSubtypeSelector): AlgorandTxSubType

  # Transaction type
  type(txType: TxTypeSelector): AlgorandTxType
}

enum AlgorandTransactionsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Fee value
  fee

  # Transaction hash
  tx_hash

  # Transaction Sender
  tx_sender
}

enum AlgorandTransactionsUniq {
  # Unique TX senders count
  senders

  # Unique blocks
  blocks

  # Unique date count
  dates

  # Unique currencies
  currencies
}

input AlgorandTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [AlgorandAddressSelector!]
  txIndex: TxIndexSelector
  sender: [AlgorandAddressSelector!]
  receiver: [AlgorandAddressSelector!]
  currency: [AlgorandCurrencySelector!]
  amount: [AmountSelector!]
  txType: TxTypeSelector
  transferType: AlgorandTransferTypeSelector
}

# Currency transfers from/to addresses in crypto currencies
type AlgorandTransfers {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AlgorandAddressSelector!], txIndex: TxIndexSelector, sender: [AlgorandAddressSelector!], receiver: [AlgorandAddressSelector!], currency: [AlgorandCurrencySelector!], amount: [AmountSelector!], txType: TxTypeSelector, transferType: AlgorandTransferTypeSelector): Float
  any(of: AlgorandTransfersMeasureable!): String

  # Block where transfer transaction is included
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AlgorandAddressSelector!], txIndex: TxIndexSelector, sender: [AlgorandAddressSelector!], receiver: [AlgorandAddressSelector!], currency: [AlgorandCurrencySelector!], amount: [AmountSelector!], txType: TxTypeSelector, transferType: AlgorandTransferTypeSelector): Int

  # Currency of transfer
  currency(currency: [AlgorandCurrencySelector!]): Currency

  # Calendar date
  date: Date
  firstRound: Int
  lastRound: Int
  maximum(of: AlgorandTransfersMeasureable!, get: AlgorandTransfersMeasureable): String
  memo: String
  minimum(of: AlgorandTransfersMeasureable!, get: AlgorandTransfersMeasureable): String

  # Transfer receiver
  receiver(receiver: [AlgorandAddressSelector!]): Address

  # Transfer sender
  sender(sender: [AlgorandAddressSelector!]): Address

  # Transaction where transfer happened
  transaction(txHash: [HashSelector!]): TransactionHashIndex

  # Transfer Type
  transferType(transferType: [AlgorandTransferType!]): AlgorandTransferType

  # Transfer transaction sender
  txSender(txSender: [AlgorandAddressSelector!]): Address

  # Transaction type in which the transfer happened
  txType(txType: [AlgorandTxType!]): AlgorandTxType
}

enum AlgorandTransfersMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Amount
  amount

  # TX Sender
  tx_sender

  # Sender
  sender

  # Receiver
  receiver

  # Currency symbol
  currency_symbol

  # Currency Asset ID
  asset_id

  # Transaction type
  tx_type

  # Transfer type
  transfer_type
}

enum AlgorandTransferType {
  # Genesis Block
  genesis

  # Create Asset
  create

  # Send
  send

  # Close
  close

  # Reward
  reward

  # Asset Freeze
  freeze

  # Asset Unfreeze
  unfreeze
}

# Select transfers by type
input AlgorandTransferTypeSelector {
  # Transfer Type is
  is: AlgorandTransferType

  # Transfer Type not
  not: AlgorandTransferType

  # Transfer Type in the list
  in: [AlgorandTransferType!]

  # Transfer Type not in the list
  notIn: [AlgorandTransferType!]
}

enum AlgorandTxSubType {
  # Send
  send

  # Close
  close

  # Create
  create

  # Asset Configuration
  configure

  # Asset Freeze
  freeze

  # Asset Unfreeze
  unfreeze

  # Key Reg
  keyreg

  # None
  none
}

enum AlgorandTxType {
  # Genesis Block
  genesis

  # Pay
  pay

  # Key Reg
  keyreg

  # Asset Configuration
  acfg

  # Asset Transfer
  axfer

  # Asset Freeze or Unfreeze
  afrz

  # Application Call
  appl
}

enum AmountAggregateFunction {
  # Maximum
  maximum

  # Minimum
  minimum

  # Sum (total)
  sum

  # Average
  average

  # Median
  median

  # Unique estimate fast
  unique

  # Unique exact
  uniqueExact

  # Any value
  any

  # Last value
  anyLast
}

# Select by amount
input AmountSelector {
  # Amount is
  is: Float

  # Amount not
  not: Float

  # Amount in the list
  in: [Float!]

  # Amount not in the list
  notIn: [Float!]

  # Amount greater than
  gt: Float

  # Amount less than
  lt: Float

  # Amount less or equal than
  lteq: Float

  # Amount greater or equal than
  gteq: Float

  # Amount in range
  between: [Float!]
}

# Selector of index of argument in call
input ArgumentIndexSelector {
  # Tx index is
  is: Int

  # Tx index not
  not: Int

  # Tx index in the list
  in: [Int!]

  # Tx index not in the list
  notIn: [Int!]
}

# Argument of Smart contract method or event
type ArgumentName {
  # Name
  name: String!

  # Type
  type: String!
}

# Argument name and value of smart contract call or event
type ArgumentNameValue {
  # Argument name
  argument: String!

  # Argument data type
  argumentType: String!

  # Sequential index of value in array ( multi-dimensional)
  index: String!

  # Value as String
  value: String!
}

# Selector of argument for smart contract method or event
input ArgumentSelector {
  # Argument is
  is: String

  # Argument not
  not: String

  # Argument in the list
  in: [String!]

  # Argument not in the list
  notIn: [String!]
}

# Selector of argument type for smart contract method or event
input ArgumentTypeSelector {
  # Argument type is
  is: String

  # Argument type not
  not: String

  # Argument type in the list
  in: [String!]

  # Argument type not in the list
  notIn: [String!]
}

# Argument value of smart contract call or event
type ArgumentValue {
  # Value as Address
  address: EthereumAddressInfo

  # Value as String
  value: String!
}

# Selector of value of argument for smart contract method or event
input ArgumentValueSelector {
  # Value is
  is: String

  # Value not
  not: String

  # Value in the list
  in: [String!]

  # Value not in the list
  notIn: [String!]
}

enum BaseCurrencyEnum {
  # Dollar
  USD

  # Ethereum
  ETH

  # Tether USDT
  USDT

  # Bitcoin
  BTC
}

# Represents non-fractional signed whole numeric values. Since the value may
# exceed the size of a 32-bit integer, it's encoded as a string.
scalar BigInt

# Binance DEX
type Binance {
  # Binance DEX Network Blocks
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: StringIdSelector, validatorMoniker: StringIdSelector, validatorFeeAddr: BinanceAddressSelector, validatorOperatorAddress: BinanceAddressSelector, validatorOperahraddress: BinanceAddressSelector, any: [BinanceBlockFilter!], options: QueryOptions): [BinanceBlock!]

  # Money flow using Coinpath technology
  coinpath(sender: BinanceAddressSelector, receiver: BinanceAddressSelector, currency: [BinanceCurrencySelector!], initialAddress: BinanceAddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [BinanceCoinpath!]

  # Binance DEX Network Exchange Orders
  orders(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, orderOwner: [BinanceAddressSelector!], orderId: [OrderIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], orderStatus: [OrderStatusSelector!], orderType: [OrderTypeSelector!], orderSide: [OrderSideSelector!], orderTimeInForce: [OrderTimeInForceSelector!], any: [BinanceOrderFilter!], options: QueryOptions): [BinanceOrders!]

  # Binance DEX Network Trades between currencies
  trades(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: [BinanceAddressSelector!], seller: [BinanceAddressSelector!], sellOrderId: [OrderIdSelector!], buyOrderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], any: [BinanceTradeFilter!], options: QueryOptions): [BinanceTrades!]

  # Binance DEX Network Transactions
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, transactionType: BinanceTransactionTypeSelector, proposalId: StringIdSelector, currency: [BinanceCurrencySelector!], transactionCode: IntIdSelector, transactionSource: IntIdSelector, deposit: [AmountSelector!], any: [BinanceTransactionFilter!], options: QueryOptions): [BinanceTransactions!]

  # Binance DEX Network Currency Transfers
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, sender: [BinanceAddressSelector!], receiver: [BinanceAddressSelector!], currency: [BinanceCurrencySelector!], transferType: [BinanceTransferTypeSelector!], orderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], amount: [AmountSelector!], outputIndex: [OutputIndexSelector!], any: [BinanceTransferFilter!], options: QueryOptions): [BinanceTransfers!]
}

# Binance Address should start with bnb and contain 42 chars.
input BinanceAddressSelector {
  # Equal to Address
  is: String

  # Not Equal to Address
  not: String

  # In the list of Addresses
  in: String

  # Not in the list of Addresses
  notIn: String
}

# Block
type BinanceBlock {
  any(of: BinanceBlocksMeasureable!): String

  # Block ID
  blockId(blockId: StringIdSelector): String
  count(uniq: BinanceBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: StringIdSelector, validatorMoniker: StringIdSelector, validatorFeeAddr: BinanceAddressSelector, validatorOperatorAddress: BinanceAddressSelector, validatorOperahraddress: BinanceAddressSelector): Int

  # Calendar date
  date: Date

  # Block number (height) in blockchain
  height(height: BlockSelector): Int!
  maximum(of: BinanceBlocksMeasureable!, get: BinanceBlocksMeasureable): String
  minimum(of: BinanceBlocksMeasureable!, get: BinanceBlocksMeasureable): String

  # Block timestamp
  timestamp(time: DateTimeSelector): DateTime

  # Validator consensus pubkey
  validatorConsensusPubkey(validatorConsensusPubkey: StringIdSelector): String

  # Validator fee address
  validatorFeeAddr(validatorFeeAddr: BinanceAddressSelector): Address

  # Validator moniker
  validatorMoniker(validatorMoniker: StringIdSelector): String

  # Validator operator HR address
  validatorOperaHrAddress(validatorOperaHrAddress: BinanceAddressSelector): Address

  # Validator operator address
  validatorOperatorAddress(validatorOperatorAddress: BinanceAddressSelector): Address
}

input BinanceBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: StringIdSelector
  validatorMoniker: StringIdSelector
  validatorFeeAddr: BinanceAddressSelector
  validatorOperatorAddress: BinanceAddressSelector
  validatorOperahraddress: BinanceAddressSelector
}

enum BinanceBlocksMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Block hash
  block_hash

  # Validator moniker
  validator_moniker
}

enum BinanceBlockUniq {
  # Validator operators
  validator_operator_addresses

  # Validator fee addresses
  validator_fee_addresses

  # Unique date count
  dates
}

# Coinpath
type BinanceCoinpath {
  # Summary of transfered value
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  # Block where transaction is included
  block: Block

  # Count of transfers
  count: Int

  # Currency of transfer
  currency: Currency

  # 1-based hop depth of the graph
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  # Receiver address
  receiver: Address

  # Sender address
  sender: Address

  # Transaction of transfer happened
  transaction: TransactionHashValue
}

# Binance token selector by tokenId.
#     Native binance token has BNB symbol.
#     Note that most Binance symbols has two dash separated parts, for example: 'TROY-9B8_BNB'
input BinanceCurrencySelector {
  # Currency is
  is: String

  # Currency not
  not: String

  # Currency in the list
  in: [String!]

  # Currency not in the list
  notIn: [String!]
}

input BinanceOrderFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  orderOwner: [BinanceAddressSelector!]
  orderId: [OrderIdSelector!]
  baseCurrency: [BinanceCurrencySelector!]
  quoteCurrency: [BinanceCurrencySelector!]
  quoteAmount: [AmountSelector!]
  baseAmount: [AmountSelector!]
  price: [AmountSelector!]
  orderStatus: [OrderStatusSelector!]
  orderType: [OrderTypeSelector!]
  orderSide: [OrderSideSelector!]
  orderTimeInForce: [OrderTimeInForceSelector!]
}

# Binance DEX Order
type BinanceOrders {
  any(of: BinanceOrdersMeasureable!): String
  baseAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, orderOwner: [BinanceAddressSelector!], orderId: [OrderIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], orderStatus: [OrderStatusSelector!], orderType: [OrderTypeSelector!], orderSide: [OrderSideSelector!], orderTimeInForce: [OrderTimeInForceSelector!]): Float
  baseCurrency(baseCurrency: [BinanceCurrencySelector!]): Currency

  # Block where order transaction is included
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: BinanceOrdersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, orderOwner: [BinanceAddressSelector!], orderId: [OrderIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], orderStatus: [OrderStatusSelector!], orderType: [OrderTypeSelector!], orderSide: [OrderSideSelector!], orderTimeInForce: [OrderTimeInForceSelector!]): Int

  # Calendar date
  date: Date
  maximum(of: BinanceOrdersMeasureable!, get: BinanceOrdersMeasureable): String
  minimum(of: BinanceOrdersMeasureable!, get: BinanceOrdersMeasureable): String

  # Order ID
  orderId(orderId: [OrderIdSelector!]): String

  # Order owner address
  orderOwner(owner: [BinanceAddressSelector!]): Address

  # Order Side
  orderSide(orderSide: [OrderSideSelector!]): BinanceOrderSide

  # Order Status
  orderStatus(orderStatus: [OrderStatusSelector!]): BinanceOrderStatus

  # Order Time In Force
  orderTimeInForce(orderTimeInForce: [OrderTimeInForceSelector!]): BinanceOrderTimeInForce

  # Order Type
  orderType(orderType: [OrderTypeSelector!]): BinanceOrderType
  price: Float
  quoteAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, orderOwner: [BinanceAddressSelector!], orderId: [OrderIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], orderStatus: [OrderStatusSelector!], orderType: [OrderTypeSelector!], orderSide: [OrderSideSelector!], orderTimeInForce: [OrderTimeInForceSelector!]): Float
  quoteCurrency(quoteCurrency: [BinanceCurrencySelector!]): Currency

  # Transaction where order created
  transaction(txHash: [HashSelector!]): TransactionHash
}

enum BinanceOrderSide {
  # Sell Side
  sell

  # Buy Side
  buy
}

enum BinanceOrdersMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Order owner
  order_owner

  # Order status
  order_status

  # Order ID
  order_id

  # Order side
  order_side

  # Base currency
  base_currency

  # Quote currency
  quote_currency

  # Quote Amount
  quote_amount

  # Base Amount
  base_amount

  # Price
  price
}

enum BinanceOrderStatus {
  # Ack
  Ack

  # Canceled
  Canceled

  # Fully Fill
  FullyFill

  # Partial Fill
  PartialFill

  # Expired
  Expired

  # Failed Blocking
  FailedBlocking

  # Ioc No Fill
  IocNoFill

  # Ioc Expire
  IocExpire
}

enum BinanceOrdersUniq {
  # Unique Transactions
  txs

  # Unique order owners
  owners

  # Unique base currencies
  base_currencies

  # Unique quote currencies
  quote_currencies

  # Unique blocks
  blocks

  # Unique date count
  dates

  # Unique order ID count
  orders
}

enum BinanceOrderTimeInForce {
  # Good Till Expiry
  GTE

  # Immediate Or Cancel
  IOC
}

enum BinanceOrderType {
  # Limit Order
  LimitOrder
}

input BinanceTradeFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  buyer: [BinanceAddressSelector!]
  seller: [BinanceAddressSelector!]
  sellOrderId: [OrderIdSelector!]
  buyOrderId: [OrderIdSelector!]
  tradeId: [TradeIdSelector!]
  baseCurrency: [BinanceCurrencySelector!]
  quoteCurrency: [BinanceCurrencySelector!]
  quoteAmount: [AmountSelector!]
  baseAmount: [AmountSelector!]
  price: [AmountSelector!]
}

# Binance DEX Trades
type BinanceTrades {
  any(of: BinanceTradesMeasureable!): String
  baseAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: [BinanceAddressSelector!], seller: [BinanceAddressSelector!], sellOrderId: [OrderIdSelector!], buyOrderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!]): Float
  baseCurrency(baseCurrency: [BinanceCurrencySelector!]): Currency

  # Block where trade transaction is included
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Buy Order ID
  buyOrderId(buyOrderId: [OrderIdSelector!]): String

  # Trade buyer address
  buyer(buyer: [BinanceAddressSelector!]): Address
  count(uniq: BinanceTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: [BinanceAddressSelector!], seller: [BinanceAddressSelector!], sellOrderId: [OrderIdSelector!], buyOrderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!]): Int

  # Calendar date
  date: Date
  maximum(of: BinanceTradesMeasureable!, get: BinanceTradesMeasureable): String
  minimum(of: BinanceTradesMeasureable!, get: BinanceTradesMeasureable): String
  price: Float
  quoteAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: [BinanceAddressSelector!], seller: [BinanceAddressSelector!], sellOrderId: [OrderIdSelector!], buyOrderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!]): Float
  quoteCurrency(quoteCurrency: [BinanceCurrencySelector!]): Currency

  # Sell Order ID
  sellOrderId(sellOrderId: [OrderIdSelector!]): String

  # Trade seller address
  seller(seller: [BinanceAddressSelector!]): Address

  # Trade ID
  tradeId(tradeId: [TradeIdSelector!]): String

  # Transaction where trade happened
  transaction(txHash: [HashSelector!]): TransactionHashIndex
}

enum BinanceTradesMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Buyer
  buyer

  # Seller
  seller

  # Trade ID
  trade_id

  # Buy Order ID
  buy_order_id

  # Sell Order ID
  sell_order_id

  # Base currency
  base_currency

  # Quote currency
  quote_currency

  # Quote Amount
  quote_amount

  # Base Amount
  base_amount

  # Price
  price
}

enum BinanceTradesUniq {
  # Trades
  trades

  # Sell Orders
  sell_orders

  # Buy Orders
  buy_orders

  # Unique Transactions
  txs

  # Unique buyers count
  buyers

  # Unique sellers count
  sellers

  # Unique base currencies
  base_currencies

  # Unique quote currencies
  quote_currencies

  # Unique blocks
  blocks

  # Unique date count
  dates
}

input BinanceTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  transactionType: BinanceTransactionTypeSelector
  proposalId: StringIdSelector
  currency: [BinanceCurrencySelector!]
  transactionCode: IntIdSelector
  transactionSource: IntIdSelector
  deposit: [AmountSelector!]
}

# Transaction
type BinanceTransactions {
  any(of: BinanceTransactionsMeasureable!): String

  # Block where transaction is included
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: BinanceTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, transactionType: BinanceTransactionTypeSelector, proposalId: StringIdSelector, currency: [BinanceCurrencySelector!], transactionCode: IntIdSelector, transactionSource: IntIdSelector, deposit: [AmountSelector!]): Int

  # Currency issued in transaction
  currency(currency: [BinanceCurrencySelector!]): Currency

  # Calendar date
  date: Date

  # Deposit amount in transaction
  deposit(deposit: [AmountSelector!]): Float

  # Transaction Description
  description: String

  # Hash hex representation
  hash(txHash: [HashSelector!]): String!

  # TX index in block, 0 based
  index: Int

  # Transaction Log
  log: String
  maximum(of: BinanceTransactionsMeasureable!, get: BinanceTransactionsMeasureable): String

  # Transaction Memo
  memo: String
  minimum(of: BinanceTransactionsMeasureable!, get: BinanceTransactionsMeasureable): String

  # Proposal ID
  proposalId(proposalId: [IntIdSelector!]): Int

  # Transaction Type
  transactionCode(transactionCode: IntIdSelector): Int

  # Transaction Source
  transactionSource(transactionSource: IntIdSelector): TransactionSource

  # Transaction Type
  transactionType(transactionType: [BinanceTransactionTypeSelector!]): BinanceTransactionType
}

enum BinanceTransactionsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Transaction Source Name
  transaction_source_name

  # Transaction Source Code
  transaction_source_code

  # Transaction Code
  transaction_code

  # Transaction Type
  transaction_type

  # Transaction Memo
  transaction_memo

  # Currency
  currency_symbol
}

enum BinanceTransactionsUniq {
  # Unique blocks
  blocks

  # Unique date count
  dates

  # Unique transaction source count
  transaction_sources
}

enum BinanceTransactionType {
  # New Order
  NEW_ORDER

  # Cancel Order
  CANCEL_ORDER

  # Transfer
  TRANSFER

  # Vote
  VOTE

  # Unfreeze Token
  UNFREEZE_TOKEN

  # Burn
  BURN

  # Freeze Token
  FREEZE_TOKEN

  # Submit Proposal
  SUBMIT_PROPOSAL

  # Listing
  LISTING

  # Issue
  ISSUE

  # Deposit
  DEPOSIT

  # Mint
  MINT

  # Time Lock
  TimeLock

  # Time Unlock
  TimeUnlock

  # Time Relock
  TimeRelock

  # Set Account Flag
  SetAccountFlag

  # Hash Timer Locked Transfer
  HTL_TRANSFER

  # Hash Timer Locked Deposit
  DEPOSIT_HTL

  # Hash Timer Locked Claim
  CLAIM_HTL

  # Hash Timer Locked  Refund
  REFUND_HTL

  # Tiny Token Issue
  TINY_TOKEN_ISSUE

  # Mini Token Issue
  MINI_TOKEN_ISSUE

  # Tiny Token Listing
  TINY_TOKEN_LIST

  # Mini Token Listing
  MINI_TOKEN_LIST

  # Tiny Token Set URI
  TINY_TOKEN_SET_URI

  # Mini Token Set URI
  MINI_TOKEN_SET_URI

  # Create sidechain validator
  CREATE_SIDECHAIN_VALIDATOR

  # Edit sidechain validator
  EDIT_SIDECHAIN_VALIDATOR

  # Delegate for sidechain
  SIDECHAIN_DELEGATE

  # ReDelegate for sidechain
  SIDECHAIN_REDELEGATE

  # Unbond from sidechain
  SIDECHAIN_UNBOND

  # Unjail from sidechain
  SIDECHAIN_UNJAIL

  # Side chain submit poroposal
  SIDE_SUBMIT_PROPOSAL

  # Side chain deposit
  SIDE_DEPOSIT

  # Side chain vote
  SIDE_VOTE

  # Cross chain transfer
  TRANSFER_OUT

  # Submit evidence
  BSC_SUBMIT_EVIDENCE

  # Cross chain claim
  CLAIM

  # Bind
  BIND

  # UnBind
  UNBIND
}

# Select by transaction type
input BinanceTransactionTypeSelector {
  # Transaction Type is
  is: BinanceTransactionType

  # Transaction Type not
  not: BinanceTransactionType

  # Transaction Type in the list
  in: [BinanceTransactionType!]

  # Transaction Type not in the list
  notIn: [BinanceTransactionType!]
}

input BinanceTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  sender: [BinanceAddressSelector!]
  receiver: [BinanceAddressSelector!]
  currency: [BinanceCurrencySelector!]
  transferType: [BinanceTransferTypeSelector!]
  orderId: [OrderIdSelector!]
  tradeId: [TradeIdSelector!]
  amount: [AmountSelector!]
  outputIndex: [OutputIndexSelector!]
}

# Currency transfers from/to addresses in crypto currencies
type BinanceTransfers {
  # Transfer amount
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, sender: [BinanceAddressSelector!], receiver: [BinanceAddressSelector!], currency: [BinanceCurrencySelector!], transferType: [BinanceTransferTypeSelector!], orderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], amount: [AmountSelector!], outputIndex: [OutputIndexSelector!]): Float
  any(of: BinanceTransfersMeasureable!): String

  # Block where transfer transaction is included
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Transfer count
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, sender: [BinanceAddressSelector!], receiver: [BinanceAddressSelector!], currency: [BinanceCurrencySelector!], transferType: [BinanceTransferTypeSelector!], orderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], amount: [AmountSelector!], outputIndex: [OutputIndexSelector!]): Int

  # Currency of transfer
  currency(currency: [BinanceCurrencySelector!]): Currency

  # Calendar date
  date: Date
  maximum(of: BinanceTransfersMeasureable!, get: BinanceTransfersMeasureable): String
  minimum(of: BinanceTransfersMeasureable!, get: BinanceTransfersMeasureable): String

  # Order Id of trade where transfer happened
  orderId(orderId: [OrderIdSelector!]): String

  # Index of the output for the transfer, 0-based
  outputIndex(outputIndex: [OutputIndexSelector!]): Int

  # Transfer receiver
  receiver(receiver: [BinanceAddressSelector!]): Address

  # Transfer sender
  sender(sender: [BinanceAddressSelector!]): Address

  # Id of trade where transfer happened
  tradeId(tradeId: [TradeIdSelector!]): String

  # Transaction where transfer happened
  transaction(txHash: [HashSelector!]): TransactionHashIndex

  # Transfer type
  transferType(transferType: [BinanceTransferTypeSelector!]): BinanceTransferType
}

enum BinanceTransfersMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Amount
  amount

  # Sender
  sender

  # Receiver
  receiver

  # Currency symbol
  currency_symbol
}

enum BinanceTransferType {
  # Reward for block
  BLOCK_REWARD

  # Burning amount
  BURN

  # Claiming Hash Timer Locked Transfer
  CLAIM_HTL

  # Deposit for Hash Timer Locked Transfer
  DEPOSIT_HTL

  # Fee for DEX orders
  DEX_FEE

  # Genesis declaration
  GENESIS_DELEGATION

  # Genesis supply declaration
  GENESIS_SUPPLY

  # Tiny Token Issue
  TINY_TOKEN_ISSUE

  # Mini Token Issue
  MINI_TOKEN_ISSUE

  # Hash Timer Locked Transfer
  HTL_TRANSFER

  # Issue token
  ISSUE

  # Mint token
  MINT

  # Trade buy side
  TRADE_BUY

  # Trade sell side
  TRADE_SELL

  # Transfer
  TRANSFER

  # Transaction fee
  TX_FEE

  # Create sidechain validator
  CREATE_SIDECHAIN_VALIDATOR

  # Edit sidechain validator
  EDIT_SIDECHAIN_VALIDATOR

  # Delegate for sidechain
  SIDECHAIN_DELEGATE

  # ReDelegate for sidechain
  SIDECHAIN_REDELEGATE

  # Unbond from sidechain
  SIDECHAIN_UNBOND

  # Side chain submit poroposal
  SIDE_SUBMIT_PROPOSAL

  # Side chain deposit
  SIDE_DEPOSIT

  # Side chain vote
  SIDE_VOTE

  # Cross chain transfer
  TRANSFER_OUT

  # Submit evidence
  BSC_SUBMIT_EVIDENCE

  # Cross chain claim
  CLAIM

  # Bind
  BIND

  # UnBind
  UNBIND
}

# Select transfer type(s)
input BinanceTransferTypeSelector {
  # Transfer type is
  is: BinanceTransferType

  # Transfer type not
  not: BinanceTransferType

  # Transfer type in the list
  in: [BinanceTransferType!]

  # Transfer type not in the list
  notIn: [BinanceTransferType!]
}

# Bitcoin and other UTXO type blockchains
type Bitcoin {
  # Blockchain Blocks
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: StringIdSelector, blockSize: IntegerSelector, blockWeight: IntegerSelector, blockVersion: IntegerSelector, transactionCount: IntegerSelector, blockStrippedSize: IntegerSelector, difficulty: FloatSelector, any: [BitcoinBlockFilter!], options: QueryOptions): [BitcoinBlock!]

  # Money flow using Coinpath technology
  coinpath(sender: AddressSelector, receiver: AddressSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: BitcoinCoinpathOptions): [BitcoinCoinpath!]

  # Blockchain Transaction Inputs
  inputs(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputScriptType: BitcoinInputScriptTypeSelector, inputValue: FloatSelector, any: [BitcoinInputFilter!], options: QueryOptions): [BitcoinTransactionInput!]

  # Blockchain Transaction Outputs
  outputs(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputScriptType: BitcoinOutputScriptTypeSelector, outputDirection: BitcoinOutputDirectionSelector, outputValue: FloatSelector, any: [BitcoinOutputFilter!], options: QueryOptions): [BitcoinTransactionOutput!]

  # Blockchain Transactions
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, any: [BitcoinTransactionFilter!], options: QueryOptions): [BitcoinTransaction!]
}

# Block
type BitcoinBlock {
  any(of: BitcoinBlocksMeasureable!): String

  # Block Hash
  blockHash(blockHash: StringIdSelector): String

  # Block size
  blockSize(blockSize: IntegerSelector): Int

  # Block stripped size
  blockStrippedSize(blockStrippedSize: IntegerSelector): Int

  # Block version
  blockVersion(blockVersion: IntegerSelector): Int

  # Block weight
  blockWeight(blockWeight: IntegerSelector): Int

  # Block chainwork
  chainwork: String
  count(uniq: BitcoinBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: StringIdSelector, blockSize: IntegerSelector, blockWeight: IntegerSelector, blockVersion: IntegerSelector, txCount: IntegerSelector, blockStrippedSize: IntegerSelector, difficulty: FloatSelector): Int

  # Calendar date
  date: Date

  # Difficulty
  difficulty(difficulty: FloatSelector): Float

  # Block number (height) in blockchain
  height(height: BlockSelector): Int!
  maximum(of: BitcoinBlocksMeasureable!, get: BitcoinBlocksMeasureable): String

  # Block median timestamp
  medianTime: DateTime
  minimum(of: BitcoinBlocksMeasureable!, get: BitcoinBlocksMeasureable): String

  # Block timestamp
  timestamp(time: DateTimeSelector): DateTime

  # Transaction count in block
  transactionCount(transactionCount: IntegerSelector): Int
}

input BitcoinBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: StringIdSelector
  blockSize: IntegerSelector
  blockWeight: IntegerSelector
  blockVersion: IntegerSelector
  transactionCount: IntegerSelector
  blockStrippedSize: IntegerSelector
  difficulty: FloatSelector
}

enum BitcoinBlocksMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Block hash
  block_hash

  # Tx Count
  transaction_count
}

enum BitcoinBlockUniq {
  # Unique date count
  dates
}

# Coinpath
type BitcoinCoinpath {
  # Summary of transfered value
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  # Block where transaction is included
  block: Block

  # Count of transfers
  count: Int

  # Currency of transfer
  currency: Currency

  # 1-based hop depth of the graph
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  # Receiver address
  receiver: Address

  # Sender address
  sender: Address

  # Transaction of transfer happened
  transaction: TransactionHashIndexValues

  # Attributes of transaction included in Coinpath result
  transactions: [CoinpathEntry!]
}

enum BitcoinCoinpathMethod {
  # Tracking money flow by amounts, ignoring coins (default)
  moneyflow

  # Tracking coins by UTXO transactions
  utxo
}

# Limits, Ordering, Constraints, Coinpath Options
input BitcoinCoinpathOptions {
  # Limit number of results
  limit: Int

  # Limit number of results by specific field
  limitBy: LimitByOption

  # Offset of results, starting from 0
  offset: Int

  # Ordering field(s) for ascending
  asc: [String!]

  # Ordering field(s) for descending
  desc: [String!]

  # Flow direction
  direction: FlowDirection

  # Do not include transactions below this amount
  minimumTxAmount: Float

  # Do not expand addresses having count transactions more than this
  maximumAddressTxCount: Int

  # Maximum total transaction count returned
  maximumTotalTxCount: Int

  # Raise error if complexity ( currently measured in transaction count ) is higher than this option
  complexityLimit: Int

  # Invalidating cache seed
  seed: Int

  # Method to use coinpath
  coinpathMethod: BitcoinCoinpathMethod
}

input BitcoinInputFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  inputIndex: IntegerSelector
  inputAddress: AddressSelector
  inOutputTxId: HashSelector
  inOutputIndex: IntegerSelector
  inputScriptType: BitcoinInputScriptTypeSelector
  inputValue: FloatSelector
}

enum BitcoinInputScriptType {
  # Input Script Signature
  scriptSig

  # Input Script TX Witness Script
  txinwitness

  # Input Script Coinbase Script
  coinbase
}

# Selector of input script type
input BitcoinInputScriptTypeSelector {
  # Equal to Script Type
  is: BitcoinInputScriptType

  # Not Equal to Script Type
  not: BitcoinInputScriptType

  # In the list of Script Type
  in: [BitcoinInputScriptType!]

  # Not in the list of Script Type
  notIn: [BitcoinInputScriptType!]
}

enum BitcoinInputsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Transaction index
  tx_index

  # Amount
  amount

  # Address
  address

  # Input index
  input_index
}

enum BitcoinInputUniq {
  # Unique transactions count
  transactions

  # Unique block count
  blocks

  # Unique date count
  dates

  # Unique addresses count
  addresses
}

enum BitcoinNetwork {
  # Bitcoin ( BTC )
  bitcoin

  # Bitcoin Cash ( BCH )
  bitcash

  # Bitcoin SV ( BSV )
  bitcoinsv

  # Litecoin ( LTC )
  litecoin

  # Dash ( DASH )
  dash

  # Dogecoin ( DOGE )
  dogecoin

  # Cardano ( ADA )
  cardano

  # ZCash ( ZCASH )
  zcash
}

enum BitcoinOutputDirection {
  # Not defined
  unknown

  # Not a change return
  not_change

  # Change return
  change

  # Likely Not a change return
  likely_not_change

  # Likely Change return
  likely_change

  # Mining
  mining

  # Fee
  fee

  # Minting
  minting

  # Genesis
  genesis
}

# A guessed direction of output
input BitcoinOutputDirectionSelector {
  # Equal to direction
  is: BitcoinOutputDirection

  # Not Equal to direction
  not: BitcoinOutputDirection

  # In the list of direction
  in: [BitcoinOutputDirection!]

  # Not in the list of direction
  notIn: [BitcoinOutputDirection!]
}

input BitcoinOutputFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  outputIndex: IntegerSelector
  outputAddress: AddressSelector
  outputScriptType: BitcoinOutputScriptTypeSelector
  outputDirection: BitcoinOutputDirectionSelector
  outputValue: FloatSelector
}

enum BitcoinOutputScriptType {
  # Output PubKey
  pubkey

  # Output PubKey Hash
  pubkeyhash

  # Output Script Hash
  scripthash

  # Output Witness Key Hash
  witness_v0_keyhash

  # Output nulldata
  nulldata

  # Output Witness Script Hash
  witness_v0_scripthash

  # Non standard output script
  nonstandard

  # Output Multisignature Wallet
  multisig

  # Output Witness Other
  witness_unknown
}

# Selector of output script type
input BitcoinOutputScriptTypeSelector {
  # Equal to Script Type
  is: BitcoinOutputScriptType

  # Not Equal to Script Type
  not: BitcoinOutputScriptType

  # In the list of Script Type
  in: [BitcoinOutputScriptType!]

  # Not in the list of Script Type
  notIn: [BitcoinOutputScriptType!]
}

enum BitcoinOutputsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Transaction index
  tx_index

  # Amount
  amount

  # Address
  address

  # Output index
  output_index
}

enum BitcoinOutputUniq {
  # Unique transactions count
  transactions

  # Unique block count
  blocks

  # Unique date count
  dates

  # Unique input addresses count
  addresses
}

# Transaction
type BitcoinTransaction {
  any(of: BitcoinTransactionsMeasureable!): String

  # Block where transaction is included
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Transaction  count
  count(uniq: BitcoinTransactionUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector): Int

  # Calendar date
  date: Date

  # Transaction total fee value
  feeValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector): Float

  # Hash hex representation
  hash(txHash: StringIdSelector): String!

  # Transaction index in block, 0-based
  index(txIndex: IntegerSelector): String!

  # Transaction total input count
  inputCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector): Int

  # Transaction total input value
  inputValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector): Float
  maximum(of: BitcoinTransactionsMeasureable!, get: BitcoinTransactionsMeasureable): String

  # Transaction total mined value
  minedValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector): Float
  minimum(of: BitcoinTransactionsMeasureable!, get: BitcoinTransactionsMeasureable): String

  # Transaction total output count
  outputCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector): Int

  # Transaction total output value
  outputValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector): Float

  # Transaction is coinbase
  txCoinbase(txCoinbase: Boolean): Boolean

  # Transaction locktime
  txLocktime(txLocktime: IntegerSelector): BigInt

  # Transaction size
  txSize(txSize: IntegerSelector): Int

  # Transaction version
  txVersion(txVersion: IntegerSelector): Int

  # Transaction vsize
  txVsize(txVsize: IntegerSelector): Int

  # Transaction weight
  txWeight(txWeight: IntegerSelector): Int
}

input BitcoinTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  txSize: IntegerSelector
  txVsize: IntegerSelector
  txWeight: IntegerSelector
  txVersion: IntegerSelector
  txCoinbase: Boolean
  inputCount: IntegerSelector
  outputCount: IntegerSelector
  inputValue: FloatSelector
  outputValue: FloatSelector
  feeValue: FloatSelector
  minedValue: FloatSelector
  txLocktime: IntegerSelector
}

# Transaction Input
type BitcoinTransactionInput {
  any(of: BitcoinInputsMeasureable!): String

  # Block where transaction is included
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Input count
  count(uniq: BitcoinInputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputScriptType: BitcoinInputScriptTypeSelector, inputValue: FloatSelector): Int

  # Calendar date
  date: Date

  # Input address
  inputAddress(inputAddress: AddressSelector): Address

  # Input index
  inputIndex(inputIndex: IntegerSelector): Int

  # Input script
  inputScript: String

  # Input script type and attributes
  inputScriptType(inputScriptType: BitcoinInputScriptTypeSelector): InputScript
  maximum(of: BitcoinInputsMeasureable!, get: BitcoinInputsMeasureable): String
  minimum(of: BitcoinInputsMeasureable!, get: BitcoinInputsMeasureable): String

  # Output Transaction for this input
  outputTransaction(inOutputTxId: StringIdSelector, inOutputIndex: IntegerSelector): TransactionHashIndex

  # Transaction ID Hash
  transaction(txId: StringIdSelector, txIndex: IntegerSelector): TransactionHashIndex

  # Input value
  value(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputScriptType: BitcoinInputScriptTypeSelector, inputValue: FloatSelector): Float
}

# Transaction Output
type BitcoinTransactionOutput {
  any(of: BitcoinOutputsMeasureable!): String

  # Block where transaction is included
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Output count
  count(uniq: BitcoinOutputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputScriptType: BitcoinOutputScriptTypeSelector, outputDirection: BitcoinOutputDirectionSelector, outputValue: FloatSelector): Int

  # Calendar date
  date: Date
  maximum(of: BitcoinOutputsMeasureable!, get: BitcoinOutputsMeasureable): String
  minimum(of: BitcoinOutputsMeasureable!, get: BitcoinOutputsMeasureable): String

  # Output address
  outputAddress(outputAddress: AddressSelector): Address

  # Output guessed direction
  outputDirection(outputDirection: BitcoinOutputDirectionSelector): BitcoinOutputDirection

  # Output index
  outputIndex(outputIndex: IntegerSelector): Int

  # Output script
  outputScript: String

  # Output script type and attributes
  outputScriptType(inputScriptType: BitcoinOutputScriptTypeSelector): OutputScript
  reqSigs: Int

  # Transaction ID Hash
  transaction(txId: StringIdSelector, txIndex: IntegerSelector): TransactionHashIndex

  # Output value
  value(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputScriptType: BitcoinOutputScriptTypeSelector, outputDirection: BitcoinOutputDirectionSelector, outputValue: FloatSelector): Float
}

enum BitcoinTransactionsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Transaction index
  tx_index

  # Input count
  input_count

  # Output count
  output_count

  # Transaction size
  tx_size

  # Transaction input value
  input_value

  # Transaction output value
  output_value
}

enum BitcoinTransactionUniq {
  # Unique block count
  blocks

  # Unique date count
  dates
}

# Block
type Block {
  # Block number (height) in blockchain
  height: Int!

  # Block timestamp
  timestamp: DateTime
}

# Blockchain network
type BlockchainNetwork {
  # Network name
  network: Network!

  # Network protocol type
  protocol: Protocol!
}

# BlockExtended
type BlockExtended {
  # Hash hex representation
  hash: String!

  # Block number (height) in blockchain
  height: Int!

  # Block timestamp
  timestamp: DateTime
}

# ConfluxBlock
type BlockInfo {
  # Block hash
  hash: String

  # Block number (height) in blockchain
  height: Int!

  # Block timestamp
  timestamp: DateTime
}

# Select block by height ( sequence number)
input BlockSelector {
  # Block height is
  is: Int

  # Block height not
  not: Int

  # Block height in the list
  in: [Int!]

  # Block height not in the list
  notIn: [Int!]

  # Block height greater than
  gt: Int

  # Block height less than
  lt: Int

  # Block height less or equal than
  lteq: Int

  # Block height greater or equal than
  gteq: Int

  # Block height in range
  between: [Int!]
}

# Select block by height ( sequence number)
input BlockSelectorRange {
  # Block height less or equal than
  lteq: Int

  # Block height greater or equal than
  gteq: Int

  # Block height in range
  between: [Int!]
}

# Transaction attributes in coinpath
type CoinpathEntry {
  # Amount involved in the flow
  amount: Float!

  # Block of transaction
  height: Int!

  # Time of transaction in ISO 8601 format
  timestamp: ISO8601DateTime!

  # Hash of transaction
  txHash: String!

  # Amount transfered in transaction
  txValue: Float!
}

enum CoinpathMeasureable {
  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Sender
  sender

  # Receiver
  receiver

  # Depth
  depth
}

# Limits, Ordering, Constraints, Coinpath Options
input CoinpathOptions {
  # Limit number of results
  limit: Int

  # Limit number of results by specific field
  limitBy: LimitByOption

  # Offset of results, starting from 0
  offset: Int

  # Ordering field(s) for ascending
  asc: [String!]

  # Ordering field(s) for descending
  desc: [String!]

  # Flow direction
  direction: FlowDirection

  # Do not include transactions below this amount
  minimumTxAmount: Float

  # Do not expand addresses having count transactions more than this
  maximumAddressTxCount: Int

  # Maximum total transaction count returned
  maximumTotalTxCount: Int

  # Raise error if complexity ( currently measured in transaction count ) is higher than this option
  complexityLimit: Int

  # Invalidating cache seed
  seed: Int
}

# Conflux Chain
type Conflux {
  # Basic information about address ( or smart contract )
  address(address: [EthereumAddressSelectorIn!]!): [EthereumAddressInfoWithBalance!]!

  # Arguments of Smart Contract Calls and Events
  arguments(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, any: [EthereumArgumentFilter!], options: QueryOptions): [EthereumArguments!]

  # Blockchain Blocks
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!], any: [ConfluxBlockFilter!], options: QueryOptions): [ConfluxBlocks!]

  # Money flow using Coinpath technology
  coinpath(sender: EthereumAddressSelector, receiver: EthereumAddressSelector, currency: [EthereumCurrencySelector!], initialAddress: EthereumAddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [EthereumCoinpath!]

  # Trades on Ethereum DEX Smart Contracts
  dexTrades(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!], any: [EthereumDexTradeFilter!], options: QueryOptions): [EthereumDexTrades!]

  # Smart Contract Calls
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, external: Boolean, success: [Boolean!], any: [EthereumSmartContractCallFilter!], options: QueryOptions): [EthereumSmartContractCalls!]

  # Smart Contract Events
  smartContractEvents(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], smartContractType: SmartContractTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector, any: [EthereumSmartContractEventFilter!], options: QueryOptions): [EthereumSmartContractEvent!]

  # Blockchain Transactions
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector, any: [ConfluxTransactionFilter!], options: QueryOptions): [ConfluxTransactions!]

  # Currency Transfers
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, amount: [AmountSelector!], any: [EthereumTransferFilter!], options: QueryOptions): [EthereumTransfers!]
}

input ConfluxBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  epoch: BlockSelector
  pivot: Boolean
  blockHash: HashSelector
  referenceBlockHash: HashSelector
  miner: [EthereumAddressSelector!]
  refereeCount: [IntegerSelector!]
  transactionCount: [IntegerSelector!]
  uncleCount: [IntegerSelector!]
  size: [IntegerSelector!]
}

# Blocks in Conflux blockchain
type ConfluxBlocks {
  # Block is adaptive
  adaptive: Boolean!
  any(of: ConfluxBlocksMeasureable!): String

  # Blame
  blame: Int!

  # Block index in epoch
  blockPosition: Int!
  count(uniq: EthereumBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int

  # Calendar date
  date: Date

  # Epoch in blockchain
  epoch(height: BlockSelector): Int!

  # Block hash
  hash(blockHash: [HashSelector!]): String!

  # Block height in blockchain
  height(height: BlockSelector): Int!
  maximum(of: ConfluxBlocksMeasureable!, get: ConfluxBlocksMeasureable): String

  # Block miner
  miner(miner: [EthereumAddressSelector!]): EthereumAddressInfo
  minimum(of: ConfluxBlocksMeasureable!, get: ConfluxBlocksMeasureable): String

  # Block nonce
  nonce: Int!

  # Parent block hash
  parentHash: String!

  # Block is pivot
  pivot: Boolean!

  # Power Quality
  powerQuality: Int!
  refereeCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int

  # Reference Block hash
  referenceBlockHash(referenceBlockHash: [HashSelector!]): String!
  size(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int

  # Block timestamp
  timestamp(time: DateTimeSelector): DateTime
  totalDifficulty(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Float
  transactionCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int

  # Hash of Transaction included in block
  txHash(txHash: [HashSelector!]): String!
  uncleCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
}

enum ConfluxBlocksMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Block hash
  block_hash

  # Block Miner
  miner

  # Block Referee Count
  referee_count

  # Block TX Count
  transaction_count
}

enum ConfluxNetwork {
  # Conflux Oceanus
  conflux_oceanus

  # Conflux Tethys
  conflux_tethys
}

input ConfluxTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [EthereumAddressSelector!]
  txTo: [EthereumAddressSelector!]
  txCreates: [EthereumAddressSelector!]
  txIndex: TxIndexSelector
  success: Boolean
  amount: [AmountSelector!]
  gasCurrency: [EthereumCurrencySelector!]
  blockHash: HashSelector
}

# Transactions in Conflux blockchain
type ConfluxTransactions {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): Float
  any(of: ConfluxTransactionsMeasureable!): String

  # Block where transfer transaction is included
  block(blockHash: HashSelector, height: BlockSelector, time: DateTimeSelector): BlockInfo
  count(uniq: EthereumTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): Int

  # Created smart contract
  creates(txCreates: [EthereumAddressSelector!]): EthereumAddressInfo

  # Currency of amount
  currency: Currency

  # Calendar date
  date: Date

  # Error message if any
  error: String
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): Int

  # Currency of gas
  gasCurrency(gasCurrency: [EthereumCurrencySelector!]): Currency

  # Gas price in Gwei
  gasPrice(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): Float!
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): Float

  # Hash hex representation
  hash(txHash: [HashSelector!]): String!

  # Transaction index in block, 0 based
  index(txIndex: [TxIndexSelector!]): Int
  maximum(of: ConfluxTransactionsMeasureable!, get: ConfluxTransactionsMeasureable): String
  minimum(of: ConfluxTransactionsMeasureable!, get: ConfluxTransactionsMeasureable): String

  # Transaction nonce
  nonce: Int

  # Transaction sender
  sender(txSender: [EthereumAddressSelector!]): EthereumAddressInfo

  # Success
  success(success: Boolean): Boolean

  # Transaction receiver
  to(txTo: [EthereumAddressSelector!]): EthereumAddressInfo
}

enum ConfluxTransactionsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Amount
  amount

  # Transaction Sender
  tx_sender

  # Gas value
  gas_value

  # Gas price
  gas_price

  # Gas used
  gas
}

enum Continent {
  # Africa
  Africa

  # Asia
  Asia

  # Europe
  Europe

  # North America
  North_America

  # Oceania
  Oceania

  # South America
  South_America

  # Antarctica
  Antarctica
}

# Continent selector
input ContinentSelector {
  # Country code is
  is: Continent

  # Country code not
  not: Continent

  # Country code in the list
  in: [Continent!]

  # Country code not in the list
  notIn: [Continent!]
}

enum CountryCode {
  # Afghanistan
  AF

  # Albania
  AL

  # Algeria
  DZ

  # American Samoa
  AS

  # Andorra
  AD

  # Angola
  AO

  # Anguilla
  AI

  # Antarctica
  AQ

  # Antigua and Barbuda
  AG

  # Argentina
  AR

  # Armenia
  AM

  # Aruba
  AW

  # Australia
  AU

  # Austria
  AT

  # Azerbaijan
  AZ

  # Bahamas
  BS

  # Bahrain
  BH

  # Bangladesh
  BD

  # Barbados
  BB

  # Belarus
  BY

  # Belgium
  BE

  # Belize
  BZ

  # Benin
  BJ

  # Bermuda
  BM

  # Bhutan
  BT

  # Bolivia
  BO

  # Bosnia and Herzegovina
  BA

  # Botswana
  BW

  # Brazil
  BR

  # British Indian Ocean Territory
  IO

  # British Virgin Islands
  VG

  # Brunei
  BN

  # Bulgaria
  BG

  # Burkina Faso
  BF

  # Burundi
  BI

  # Cambodia
  KH

  # Cameroon
  CM

  # Canada
  CA

  # Cape Verde
  CV

  # Cayman Islands
  KY

  # Central African Republic
  CF

  # Chad
  TD

  # Chile
  CL

  # China
  CN

  # Christmas Island
  CX

  # Cocos Islands
  CC

  # Colombia
  CO

  # Comoros
  KM

  # Cook Islands
  CK

  # Costa Rica
  CR

  # Croatia
  HR

  # Cuba
  CU

  # Curacao
  CW

  # Cyprus
  CY

  # Czech Republic
  CZ

  # Democratic Republic of the Congo
  CD

  # Denmark
  DK

  # Djibouti
  DJ

  # Dominica
  DM

  # Dominican Republic
  DO

  # East Timor
  TL

  # Ecuador
  EC

  # Egypt
  EG

  # El Salvador
  SV

  # Equatorial Guinea
  GQ

  # Eritrea
  ER

  # Estonia
  EE

  # Ethiopia
  ET

  # Falkland Islands
  FK

  # Faroe Islands
  FO

  # Fiji
  FJ

  # Finland
  FI

  # France
  FR

  # French Polynesia
  PF

  # Gabon
  GA

  # Gambia
  GM

  # Georgia
  GE

  # Germany
  DE

  # Ghana
  GH

  # Gibraltar
  GI

  # Greece
  GR

  # Greenland
  GL

  # Grenada
  GD

  # Guam
  GU

  # Guatemala
  GT

  # Guernsey
  GG

  # Guinea
  GN

  # Guinea-Bissau
  GW

  # Guyana
  GY

  # Haiti
  HT

  # Honduras
  HN

  # Hong Kong
  HK

  # Hungary
  HU

  # Iceland
  IS

  # India
  IN

  # Indonesia
  ID

  # Iran
  IR

  # Iraq
  IQ

  # Ireland
  IE

  # Isle of Man
  IM

  # Israel
  IL

  # Italy
  IT

  # Ivory Coast
  CI

  # Jamaica
  JM

  # Japan
  JP

  # Jersey
  JE

  # Jordan
  JO

  # Kazakhstan
  KZ

  # Kenya
  KE

  # Kiribati
  KI

  # Kosovo
  XK

  # Kuwait
  KW

  # Kyrgyzstan
  KG

  # Laos
  LA

  # Latvia
  LV

  # Lebanon
  LB

  # Lesotho
  LS

  # Liberia
  LR

  # Libya
  LY

  # Liechtenstein
  LI

  # Lithuania
  LT

  # Luxembourg
  LU

  # Macau
  MO

  # Macedonia
  MK

  # Madagascar
  MG

  # Malawi
  MW

  # Malaysia
  MY

  # Maldives
  MV

  # Mali
  ML

  # Malta
  MT

  # Marshall Islands
  MH

  # Mauritania
  MR

  # Mauritius
  MU

  # Mayotte
  YT

  # Mexico
  MX

  # Micronesia
  FM

  # Moldova
  MD

  # Monaco
  MC

  # Mongolia
  MN

  # Montenegro
  ME

  # Montserrat
  MS

  # Morocco
  MA

  # Mozambique
  MZ

  # Myanmar
  MM

  # Namibia
  NA

  # Nauru
  NR

  # Nepal
  NP

  # Netherlands
  NL

  # Netherlands Antilles
  AN

  # New Caledonia
  NC

  # New Zealand
  NZ

  # Nicaragua
  NI

  # Niger
  NE

  # Nigeria
  NG

  # Niue
  NU

  # North Korea
  KP

  # Northern Mariana Islands
  MP

  # Norway
  NO

  # Oman
  OM

  # Pakistan
  PK

  # Palau
  PW

  # Palestine
  PS

  # Panama
  PA

  # Papua New Guinea
  PG

  # Paraguay
  PY

  # Peru
  PE

  # Philippines
  PH

  # Pitcairn
  PN

  # Poland
  PL

  # Portugal
  PT

  # Puerto Rico
  PR

  # Qatar
  QA

  # Republic of the Congo
  CG

  # Reunion
  RE

  # Romania
  RO

  # Russia
  RU

  # Rwanda
  RW

  # Saint Barthelemy
  BL

  # Saint Helena
  SH

  # Saint Kitts and Nevis
  KN

  # Saint Lucia
  LC

  # Saint Martin
  MF

  # Saint Pierre and Miquelon
  PM

  # Saint Vincent and the Grenadines
  VC

  # Samoa
  WS

  # San Marino
  SM

  # Sao Tome and Principe
  ST

  # Saudi Arabia
  SA

  # Senegal
  SN

  # Serbia
  RS

  # Seychelles
  SC

  # Sierra Leone
  SL

  # Singapore
  SG

  # Sint Maarten
  SX

  # Slovakia
  SK

  # Slovenia
  SI

  # Solomon Islands
  SB

  # Somalia
  SO

  # South Africa
  ZA

  # South Korea
  KR

  # South Sudan
  SS

  # Spain
  ES

  # Sri Lanka
  LK

  # Sudan
  SD

  # Suriname
  SR

  # Svalbard and Jan Mayen
  SJ

  # Swaziland
  SZ

  # Sweden
  SE

  # Switzerland
  CH

  # Syria
  SY

  # Taiwan
  TW

  # Tajikistan
  TJ

  # Tanzania
  TZ

  # Thailand
  TH

  # Togo
  TG

  # Tokelau
  TK

  # Tonga
  TO

  # Trinidad and Tobago
  TT

  # Tunisia
  TN

  # Turkey
  TR

  # Turkmenistan
  TM

  # Turks and Caicos Islands
  TC

  # Tuvalu
  TV

  # U.S. Virgin Islands
  VI

  # Uganda
  UG

  # Ukraine
  UA

  # United Arab Emirates
  AE

  # United Kingdom
  GB

  # United States
  US

  # Uruguay
  UY

  # Uzbekistan
  UZ

  # Vanuatu
  VU

  # Vatican
  VA

  # Venezuela
  VE

  # Vietnam
  VN

  # Wallis and Futuna
  WF

  # Western Sahara
  EH

  # Yemen
  YE

  # Zambia
  ZM

  # Zimbabwe
  ZW
}

# Country selector by 3 digit ISO code
input CountrySelector {
  # Country code is
  is: CountryCode

  # Country code not
  not: CountryCode

  # Country code in the list
  in: [CountryCode!]

  # Country code not in the list
  notIn: [CountryCode!]
}

# Country
type CovidCountry {
  # Area, km2
  areaKm2: Float

  # Continent name
  continent: Continent

  # Gross Domestic Product
  gdp: Float

  # ISO 2 letter code
  iso2: CountryCode

  # ISO 3 letter code
  iso3: String

  # ISO numeric code
  isoNumeric: Int

  # Location latitude
  latitude: Float

  # Location longitude
  longitude: Float

  # Country name
  name: String

  # Population density in thousands per km2
  populationPerKm2: Float

  # Population total in thousands
  populationTotal: Float
}

# Facts of Covid virus development
type CovidFact {
  # Count of confirmed cases
  confirmed(date: DateSelector, country: CountrySelector, continent: ContinentSelector): Int

  # Country
  country(country: CountrySelector, continent: ContinentSelector): CovidCountry

  # Calendar date
  date: Date

  # Count of death cases
  deaths(date: DateSelector, country: CountrySelector, continent: ContinentSelector): Int

  # Location
  location: CovidLocation

  # Count of recovered cases
  recovered(date: DateSelector, country: CountrySelector, continent: ContinentSelector): Int
}

# Covid History
type CovidHistory {
  # COVID daily facts
  facts(date: DateSelector, country: CountrySelector, continent: ContinentSelector, options: QueryOptions): [CovidFact!]
}

# Geo Location
type CovidLocation {
  # Admin center name
  adminCenter: String

  # FIPS code for USA
  fipsCode: Int

  # Location latitude
  latitude: Float

  # Location longitude
  longitude: Float

  # Location Country name
  name: String

  # Location Province / State name
  province: String
}

# Crypto currency ( token, coin, currency )
type Currency {
  # Token Smart Contract Address
  address: String

  # Decimals
  decimals: Int!

  # Currency name
  name: String

  # Currency symbol
  symbol: String!

  # Token ID
  tokenId: String

  # Token Type
  tokenType: String
}

# Date
type Date {
  # String date representation with default format as YYYY-MM-DD
  date(format: String): String!

  # Day of month (1-31)
  dayOfMonth: Int!

  # Day of week  (Monday is 1, and Sunday is 7)
  dayOfWeek: Int!

  # Month number (1-12)
  month: Int!

  # Returns start of date interval ,
  #     date representation with default format as YYYY-MM-DD. Example is start of interval for 3 weeks each,
  #   starting on wednesdays will read as: 'startOfInterval(unit: week, interval: 3, offset: 2)'
  startOfInterval(format: String, interval: Int, offset: Int, unit: DateInterval!): String!

  # Year number
  year: Int!
}

enum DateInterval {
  # Year
  year

  # Month
  month

  # Week
  week

  # Day
  day
}

# Selecting the date in a range, list or just date
input DateSelector {
  # Since date
  since: ISO8601DateTime

  # Till date
  till: ISO8601DateTime

  # Range of dates
  between: [ISO8601DateTime!]

  # Before date
  before: ISO8601DateTime

  # After date
  after: ISO8601DateTime

  # In dates
  in: [ISO8601DateTime!]

  # Not in dates
  notIn: [ISO8601DateTime!]

  # Date equals
  is: ISO8601DateTime

  # Date not equals
  not: ISO8601DateTime
}

# Date and Time
type DateTime {
  # Day of month (1-31)
  dayOfMonth: Int!

  # Day of week  (Monday is 1, and Sunday is 7)
  dayOfWeek: Int!

  # Hour (0-23)
  hour: Int!

  # ISO8601 date time such as '2020-03-02T13:30:41+00:00'
  iso8601: ISO8601DateTime!

  # Minute (0-59)
  minute: Int!

  # Month number (1-12)
  month: Int!

  # Second (0-59)
  second: Int!

  # String date representation with default format as YYYY-MM-DD
  time(format: String): String!

  # Unix timestamp
  unixtime: Int!

  # Year number
  year: Int!
}

# Selecting the time in a range, list or just time
input DateTimeSelector {
  # Since time
  since: ISO8601DateTime

  # Till time
  till: ISO8601DateTime

  # Range of time
  between: [ISO8601DateTime!]

  # Before time
  before: ISO8601DateTime

  # After time
  after: ISO8601DateTime

  # In times
  in: [ISO8601DateTime!]

  # Not in times
  notIn: [ISO8601DateTime!]

  # Time equals
  is: ISO8601DateTime

  # Time not equals
  not: ISO8601DateTime
}

enum DiemNetwork {
  # Diem Testnet
  diem_testnet

  # Libra Testnet
  libra_testnet
}

# Selector of entity ID for NFT  tokens
input EntitySelector {
  # EntityID is
  is: String

  # EntityID not
  not: String

  # EntityID in the list
  in: [String!]

  # EntityID not in the list
  notIn: [String!]
}

# EOS Chain
type Eos {
  # Basic information about address ( or smart contract )
  address(address: [AddressSelectorIn!]!): [EosAddressInfo!]!

  # Blockchain Blocks
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: AddressSelector, any: [EosBlockFilter!], options: QueryOptions): [EosBlocks!]

  # Money flow using Coinpath technology
  coinpath(sender: AddressSelector, receiver: AddressSelector, currency: EosCurrencySelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [EosCoinpath!]

  # Smart Contract Calls
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean, scheduled: Boolean, any: [EosSmartContractCallFilter!], options: QueryOptions): [EosSmartContractCalls!]

  # Blockchain Transactions
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, scheduled: Boolean, any: [EosTransactionFilter!], options: QueryOptions): [EosTransactions!]

  # Currency Transfers
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: EosCurrencySelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!], any: [EosTransferFilter!], options: QueryOptions): [EosTransfers!]
}

# Address detailed information for EOS network
type EosAddressInfo {
  # String address representation
  address: String!

  # Annotations ( tags ), if exists
  annotation: String

  # Smart Contract if exists on the address
  smartContract: EosSmartContractInfo
}

input EosBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  proposer: AddressSelector
}

# Blocks in EOS blockchain
type EosBlocks {
  any(of: EosBlocksMeasureable!): String
  count(uniq: EosBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: AddressSelector): Int

  # Calendar date
  date: Date

  # Block hash
  hash(blockHash: [HashSelector!]): String!

  # Block number (height) in blockchain
  height(height: BlockSelector): Int!
  maximum(of: EosBlocksMeasureable!, get: EosBlocksMeasureable): String
  minimum(of: EosBlocksMeasureable!, get: EosBlocksMeasureable): String

  # Block producer
  producer(producer: AddressSelector): Address

  # Block timestamp
  timestamp(time: DateTimeSelector): DateTime
}

enum EosBlocksMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Block hash
  block_hash

  # Block Proposer
  proposer
}

enum EosBlocksUniq {
  # Unique proposer count
  proposers

  # Unique date count
  dates
}

enum EosCallsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Sender
  tx_sender

  # Action From
  tx_from

  # Action To
  tx_to

  # Smart Contract
  smart_contract

  # Smart Contract Method Name
  signature_name

  # Smart Contract Method Signature
  signature

  # Smart Contract Method Signature Hash
  signature_hash

  # Call depth
  call_depth
}

# Coinpath
type EosCoinpath {
  # Summary of transfered value
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  # Block where transaction is included
  block: Block

  # Count of transfers
  count: Int

  # Currency of transfer
  currency: Currency

  # 1-based hop depth of the graph
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  # Receiver address
  receiver: EosAddressInfo

  # Sender address
  sender: EosAddressInfo

  # Transaction of transfer happened
  transaction: TransactionHashValue
}

# Currency selector in EOS blockchain.
# Token identified by address of contract ( eosio.token for main EOS token )
input EosCurrencySelector {
  # Currency is
  is: String

  # Currency not
  not: String

  # Currency in the list
  in: [String!]

  # Currency not in the list
  notIn: [String!]
}

# Eos smart contract
type EosSmartContract {
  # Smart Contract Address
  address: Address!

  # Smart Contract Type
  contractType: SmartContractType

  # Token implemented in this smart contract
  currency: Currency

  # Smart Contract Protocol Type
  protocolType: String
}

input EosSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  smartContractAddress: AddressSelector
  smartContractMethod: MethodSelector
  external: Boolean
  success: Boolean
  scheduled: Boolean
}

# Smart Contract Calls
type EosSmartContractCalls {
  # Actors
  actors: String
  any(of: EosCallsMeasureable!): String

  # Block in the blockchain
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Depth of the call. Empty string for external call, then counted as 0...N, and
  # the next layer is added through '-'. For example 0-3-9.
  callDepth: String

  # Console
  console: String

  # Counts and other metrics
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean, scheduled: Boolean): Int

  # Calendar date
  date: Date

  # Error Code
  errorCode(errorCode: IntIdSelector): Int

  # External call executed explicitly by tx sender. Internal calls executed by smart contracts.
  external(external: Boolean): Boolean
  maximum(of: EosCallsMeasureable!, get: EosCallsMeasureable): String
  minimum(of: EosCallsMeasureable!, get: EosCallsMeasureable): String

  # Permissions
  permissions: String

  # Receivers
  receivers: String

  # True if call scheduled
  scheduled(scheduled: [Boolean!]): Boolean

  # Smart contract being called
  smartContract(smartContractAddress: AddressSelector): EosSmartContract

  # Contract method invoked
  smartContractMethod(smartContractMethod: MethodSelector): Method

  # True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  success(success: [Boolean!]): Boolean

  # Action from address
  txFrom(txFrom: AddressSelector): Address

  # Transaction hash where transfer happened
  txHash(txHash: HashSelector): String

  # Action to address
  txTo(txTo: AddressSelector): Address
}

# Blockchain smart contract
type EosSmartContractInfo {
  # Smart Contract Type
  contractType: SmartContractType

  # Token implemented in this smart contract
  currency: Currency

  # Smart Contract Protocol Type
  protocolType: String
}

input EosTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: TxIndexSelector
  success: Boolean
  scheduled: Boolean
}

# Transactions in EOS blockchain
type EosTransactions {
  any(of: EosTransactionsMeasureable!): String

  # Block where transfer transaction is included
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: EosTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, scheduled: Boolean): Int
  cpuUsageUs(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, scheduled: Boolean): Int

  # Calendar date
  date: Date

  # Hash hex representation
  hash(txHash: [HashSelector!]): String!

  # Transaction index in block, 0 based
  index(txIndex: [TxIndexSelector!]): Int
  maximum(of: EosTransactionsMeasureable!, get: EosTransactionsMeasureable): String
  minimum(of: EosTransactionsMeasureable!, get: EosTransactionsMeasureable): String
  netUsageWords(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, scheduled: Boolean): Int

  # Success
  scheduled(scheduled: Boolean): Boolean

  # Success
  success(success: Boolean): Boolean
}

enum EosTransactionsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # CPU Usage
  cpu_usage_us

  # Net Usage
  net_usage_words
}

enum EosTransactionsUniq {
  # Unique blocks
  blocks

  # Unique date count
  dates
}

input EosTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  sender: AddressSelector
  receiver: AddressSelector
  currency: EosCurrencySelector
  entityId: EntitySelector
  external: Boolean
  success: Boolean
  amount: [AmountSelector!]
}

# Currency transfers from/to addresses in crypto currencies
type EosTransfers {
  # Actors
  actors: String
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: EosCurrencySelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Float
  any(of: EosTransfersMeasureable!): String

  # Block where transfer transaction is included
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: EosCurrencySelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Int

  # Currency of transfer
  currency(currency: EosCurrencySelector): Currency

  # Calendar date
  date: Date

  # Entity identifier ( for ERC-721 NFT tokens )
  entityId(entityId: EntitySelector): String

  # External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts.
  external(external: Boolean): Boolean
  maximum(of: EosTransfersMeasureable!, get: EosTransfersMeasureable): String

  # Memo
  memo: String
  minimum(of: EosTransfersMeasureable!, get: EosTransfersMeasureable): String

  # Transfer receiver
  receiver(receiver: AddressSelector): Address

  # Transfer sender
  sender(sender: AddressSelector): Address

  # Transfer succeeded
  success(success: Boolean): Boolean

  # Action from address
  txFrom(txFrom: AddressSelector): Address

  # Transaction hash where transfer happened
  txHash(txHash: HashSelector): String

  # Action to address
  txTo(txTo: AddressSelector): Address
}

enum EosTransfersMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Amount
  amount

  # Sender
  sender

  # Receiver
  receiver

  # Currency symbol
  currency_symbol

  # Token address
  currency_address
}

# Ethereum Chain
type Ethereum {
  # Basic information about address ( or smart contract )
  address(address: [EthereumAddressSelectorIn!]!): [EthereumAddressInfoWithBalance!]!

  # Arguments of Smart Contract Calls and Events
  arguments(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, any: [EthereumArgumentFilter!], options: QueryOptions): [EthereumArguments!]

  # Blockchain Blocks
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!], any: [EthereumBlockFilter!], options: QueryOptions): [EthereumBlocks!]

  # Money flow using Coinpath technology
  coinpath(sender: EthereumAddressSelector, receiver: EthereumAddressSelector, currency: [EthereumCurrencySelector!], initialAddress: EthereumAddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [EthereumCoinpath!]

  # Trades on Ethereum DEX Smart Contracts
  dexTrades(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!], any: [EthereumDexTradeFilter!], options: QueryOptions): [EthereumDexTrades!]

  # Smart Contract Calls
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, external: Boolean, success: [Boolean!], any: [EthereumSmartContractCallFilter!], options: QueryOptions): [EthereumSmartContractCalls!]

  # Smart Contract Events
  smartContractEvents(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], smartContractType: SmartContractTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector, any: [EthereumSmartContractEventFilter!], options: QueryOptions): [EthereumSmartContractEvent!]

  # Blockchain Transactions
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!], any: [EthereumTransactionFilter!], options: QueryOptions): [EthereumTransactions!]

  # Currency Transfers
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, amount: [AmountSelector!], any: [EthereumTransferFilter!], options: QueryOptions): [EthereumTransfers!]
}

# Ethereum v 2.0 Baecon Chain
type Ethereum2 {
  # Attestations in block
  attestations(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], committeeIndex: [IntegerSelector!], attestationSlot: [IntegerSelector!], attestationEpoch: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2Attestation!]

  # Attester Slashings
  attesterSlashings(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], attestationSlot: [IntegerSelector!], attestationEpoch: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2AttesterSlashing!]

  # Blockchain Blocks
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2Blocks!]

  # Attestations of blocks
  deposits(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2Deposit!]

  # Proposer Slashings
  proposerSlashings(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], slashingProposerIndex: [IntegerSelector!], slashingSlot: [IntegerSelector!], slashingEpoch: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2ProposerSlashing!]

  # Voluntary Exits
  voluntaryExits(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], voluntaryExitEpoch: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2VoluntaryExit!]
}

# Attestations in Ethereum v2.0 blockchain
type Ethereum2Attestation {
  aggregationBits: String!
  any(of: Ethereum2AttestationsMeasureable!): String
  attestation: Ethereum2AttestationInfo!

  # Attestation Index (0 based ) in block
  attestationIndex: Int!

  # Block in the blockchain
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Block root hash
  blockRoot(blockRootHash: [HashSelector!]): String!

  # Committee index for attestation
  committeeIndex: Int!
  count(uniq: Ethereum2AttestationsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], committeeIndex: [IntegerSelector!], attestationSlot: [IntegerSelector!], attestationEpoch: [IntegerSelector!]): BigInt

  # Calendar date
  date: Date

  # Block Eth1 information
  eth1: Ethereum2Eth1Info!
  maximum(of: Ethereum2AttestationsMeasureable!, get: Ethereum2AttestationsMeasureable): String
  minimum(of: Ethereum2AttestationsMeasureable!, get: Ethereum2AttestationsMeasureable): String

  # Block parent hash
  parentRoot: String!

  # Block proposer
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo

  # Block state root hash
  stateRoot: String!

  # Validator
  validator: Ethereum2ValidatorInfo!

  # Sequential index of validator in committee ( 0-based)
  validatorInCommitteeIndex: Int!
}

# AttestationFieldInfo for Ethereum v 2.0 network
type Ethereum2AttestationFieldInfo {
  epoch: Int!

  # Root Hash
  root: String!
}

# AttestationInfo for Ethereum v 2.0 network
type Ethereum2AttestationInfo {
  beaconBlockRoot: String!
  epoch: Int!
  signature: String!
  slot: Int!
  source: Ethereum2AttestationFieldInfo!
  target: Ethereum2AttestationFieldInfo!
}

enum Ethereum2AttestationsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Block hash
  block_root_hash

  # Block Proposer
  block_proposer

  # Committee Index
  committee

  # Validator index
  validator
}

enum Ethereum2AttestationsUniq {
  # Unique blocks
  blocks

  # Unique block proposers
  block_proposers

  # Unique date count
  dates

  # Unique commitees
  committees

  # Unique validators
  validators

  # Unique attestations
  attestations

  # Unique attestation slots
  attestation_slots

  # Unique attestation epochs
  attestation_epochs
}

# Attester Slashing in Ethereum v2.0 blockchain
type Ethereum2AttesterSlashing {
  any(of: Ethereum2AttesterSlashingMeasureable!): String
  attestation: Ethereum2AttestationInfo!

  # Attestation slashing sequential number
  attestationOrder: Int!

  # Attester Slashing Index (0 based ) in block
  attesterSlashingIndex: Int!

  # Block in the blockchain
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Block root hash
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(uniq: Ethereum2AttesterSlashingsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], attestationSlot: [IntegerSelector!], attestationEpoch: [IntegerSelector!]): Int

  # Calendar date
  date: Date

  # Block Eth1 information
  eth1: Ethereum2Eth1Info!
  maximum(of: Ethereum2AttesterSlashingMeasureable!, get: Ethereum2AttesterSlashingMeasureable): String
  minimum(of: Ethereum2AttesterSlashingMeasureable!, get: Ethereum2AttesterSlashingMeasureable): String

  # Block parent hash
  parentRoot: String!

  # Block proposer
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo

  # Block state root hash
  stateRoot: String!

  # Validator
  validator: Ethereum2ValidatorInfo!

  # Validator index in slashing sequential numbern
  validatorInAttestationIndex: Int!
}

enum Ethereum2AttesterSlashingMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Block hash
  block_root_hash

  # Block Proposer
  block_proposer

  # Validator index
  validator
}

enum Ethereum2AttesterSlashingsUniq {
  # Unique blocks
  blocks

  # Unique block proposers
  block_proposers

  # Unique date count
  dates

  # Unique validators
  validators

  # Unique slashing slots
  attestation_slots

  # Unique slashing epochs
  attestation_epochs
}

# Blocks in Ethereum v2.0 blockchain
type Ethereum2Blocks {
  any(of: Ethereum2BlocksMeasureable!): String
  attestationsCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int
  attesterSlashingsCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int

  # Block root hash
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(uniq: Ethereum2BlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int

  # Calendar date
  date: Date
  depositsCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int

  # Block Eth1 information
  eth1: Ethereum2Eth1Info!

  # Graffiti
  graffiti: String!

  # Block number (height) in blockchain
  height(height: BlockSelector): Int!
  maximum(of: Ethereum2BlocksMeasureable!, get: Ethereum2BlocksMeasureable): String
  minimum(of: Ethereum2BlocksMeasureable!, get: Ethereum2BlocksMeasureable): String

  # Block parent hash
  parentRoot: String!

  # Block proposer
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo
  proposerSlashingsCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int

  # Randao Reveal
  randaoReveal: String!

  # Block signature
  signature: String!

  # Block state root hash
  stateRoot: String!

  # Block timestamp
  timestamp(time: DateTimeSelector): DateTime
  voluntaryExitsCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int
}

enum Ethereum2BlocksMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Block hash
  block_root_hash

  # Block Miner
  block_proposer
}

enum Ethereum2BlocksUniq {
  # Unique proposers
  block_proposers

  # Unique date count
  dates
}

# Deposit in Ethereum v2.0 blockchain
type Ethereum2Deposit {
  amount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!]): Float
  any(of: Ethereum2DepositsMeasureable!): String

  # Block in the blockchain
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Block root hash
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(uniq: Ethereum2DepositsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int

  # Calendar date
  date: Date

  # Deposit Index (0 based ) in block
  depositIndex: Int!

  # Block Eth1 information
  eth1: Ethereum2Eth1Info!
  maximum(of: Ethereum2DepositsMeasureable!, get: Ethereum2DepositsMeasureable): String
  minimum(of: Ethereum2DepositsMeasureable!, get: Ethereum2DepositsMeasureable): String

  # Block parent hash
  parentRoot: String!
  proof: String!

  # Block proposer
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo
  signature: String!

  # Block state root hash
  stateRoot: String!

  # Validator
  validator: Ethereum2ValidatorInfo!
}

enum Ethereum2DepositsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Block hash
  block_root_hash

  # Block Proposer
  block_proposer

  # Validator index
  validator
}

enum Ethereum2DepositsUniq {
  # Unique blocks
  blocks

  # Unique block proposers
  block_proposers

  # Unique date count
  dates

  # Unique validators
  validators
}

# Eth1 attributes for Ethereum v 2.0 network
type Ethereum2Eth1Info {
  # Block Eth1 block hash
  blockHash: String!

  # Block Eth1 deposit count
  depositCount: Int!

  # Block Eth1 deposit root hash
  depositRoot: String!
}

input Ethereum2Filter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockRootHash: HashSelector
  blockProposerIndex: [IntegerSelector!]
}

enum Ethereum2Network {
  # Beacon Chain Ethereum 2.0
  eth2

  # Medalla Ethereum 2.0 Beacon Testnet
  medalla
}

# Proposer Slashing in Ethereum v2.0 blockchain
type Ethereum2ProposerSlashing {
  any(of: Ethereum2ProposerSlashingMeasureable!): String

  # Block in the blockchain
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Block root hash
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(uniq: Ethereum2ProposerSlashingsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], slashingProposerIndex: [IntegerSelector!], slashingSlot: [IntegerSelector!], slashingEpoch: [IntegerSelector!]): Int

  # Calendar date
  date: Date

  # Block Eth1 information
  eth1: Ethereum2Eth1Info!

  # Header slashing sequential numbern
  headerOrder: Int!
  maximum(of: Ethereum2ProposerSlashingMeasureable!, get: Ethereum2ProposerSlashingMeasureable): String
  minimum(of: Ethereum2ProposerSlashingMeasureable!, get: Ethereum2ProposerSlashingMeasureable): String

  # Block parent hash
  parentRoot: String!

  # Block proposer
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo

  # Proposer Slashing Index (0 based ) in block
  proposerSlashingIndex: Int!
  slashing: Ethereum2SlashingInfo!

  # Block state root hash
  stateRoot: String!
}

enum Ethereum2ProposerSlashingMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Block hash
  block_root_hash

  # Block Proposer
  block_proposer

  # Slashed Proposer
  proposer
}

enum Ethereum2ProposerSlashingsUniq {
  # Unique blocks
  blocks

  # Unique block proposers
  block_proposers

  # Unique date count
  dates

  # Unique slashing slots
  slashing_slots

  # Unique slashing epochs
  slashing_epochs

  # Unique slashing proposers
  slashing_proposers
}

# SlashingInfo for Ethereum v 2.0 network
type Ethereum2SlashingInfo {
  # Block body hash
  bodyRoot: String!
  epoch: Int!

  # Block parent hash
  parentRoot: String!

  # Block proposer
  proposer: Ethereum2ValidatorInfo
  signature: String!
  slot: Int!

  # Block state root hash
  stateRoot: String!
}

# Validator attributes for Ethereum v 2.0 network
type Ethereum2ValidatorInfo {
  # Validator Index as Integer
  index: Int!

  # Validator Pub Key
  pubkey: String!

  # Validator Withdrawal
  withdrawalCredentials: String!
}

# Voluntary Exit in Ethereum v2.0 blockchain
type Ethereum2VoluntaryExit {
  any(of: Ethereum2VoluntaryExitsMeasureable!): String

  # Block in the blockchain
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Block root hash
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(uniq: Ethereum2VoluntaryExitsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], voluntaryExitEpoch: [IntegerSelector!]): Int

  # Calendar date
  date: Date

  # Block Eth1 information
  eth1: Ethereum2Eth1Info!
  maximum(of: Ethereum2VoluntaryExitsMeasureable!, get: Ethereum2VoluntaryExitsMeasureable): String
  minimum(of: Ethereum2VoluntaryExitsMeasureable!, get: Ethereum2VoluntaryExitsMeasureable): String

  # Block parent hash
  parentRoot: String!

  # Block proposer
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo

  # Signature
  signature: String!

  # Block state root hash
  stateRoot: String!

  # Validator
  validator: Ethereum2ValidatorInfo!
  voluntaryExitEpoch: Int!

  # Voluntary Exit Index (0 based ) in block
  voluntaryExitIndex: Int!
}

enum Ethereum2VoluntaryExitsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Block hash
  block_root_hash

  # Block Proposer
  block_proposer

  # Validator index
  validator
}

enum Ethereum2VoluntaryExitsUniq {
  # Unique blocks
  blocks

  # Unique block proposers
  block_proposers

  # Unique date count
  dates

  # Unique validators
  validators
}

# Address detailed information for Ethereum network
type EthereumAddressInfo {
  # String address representation
  address: String!

  # Annotations ( tags ), if exists
  annotation: String

  # Smart Contract if exists on the address
  smartContract: EthereumSmartContractInfo
}

# Blockchain address
type EthereumAddressInfoWithBalance {
  # String address representation
  address: String!

  # Annotations ( tags ), if exists
  annotation: String

  # DEPRECATED Current address balance
  balance: Float

  # DEPRECATED Balances by currencies for the address
  balances(date: DateSelector, time: DateTimeSelector, currency: EthereumCurrencySelector, height: BlockSelectorRange): [EthereumBalance!]

  # Smart Contract if exists on the address
  smartContract: EthereumSmartContractInfoWithAttributes
}

# Address should start from 0x and contain hex digits.
#   If digits are case sensitive, address is checked against checksum according to EIP-55.
input EthereumAddressSelector {
  # Equal to Address
  is: String

  # Not Equal to Address
  not: String

  # In the list of Addresses
  in: [String!]

  # Not in the list of Addresses
  notIn: [String!]
}

# Address should start from 0x and contain hex digits.
#   If digits are case sensitive, address is checked against checksum according to EIP-55.
input EthereumAddressSelectorIn {
  # Equal to Address
  is: String

  # In the list of Addresses
  in: [String!]
}

input EthereumArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [EthereumAddressSelector!]
  caller: [EthereumAddressSelector!]
  reference: [EthereumAddressSelector!]
  value: [ArgumentValueSelector!]
  argument: [ArgumentSelector!]
  argumentType: [ArgumentTypeSelector!]
  signatureType: SignatureTypeSelector
  smartContractAddress: [EthereumAddressSelector!]
  smartContractMethod: MethodSelector
  smartContractEvent: EventSelector
  external: Boolean
}

# Arguments of Smart Contract Calls and Events
type EthereumArguments {
  any(of: EthereumArgumentsMeasureable!, as: EthereumArgumentsConvertable, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean): String

  # Method or event argument
  argument(argument: [ArgumentSelector!], argumentType: String): ArgumentName

  # Block in the blockchain
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Depth of the call. Empty string for external call, then counted as 0...N, and
  # the next layer is added through '-'. For example 0-3-9.
  callDepth: String

  # Caller of the method invocation ( tx sender or another smart contract )
  caller(caller: [EthereumAddressSelector!]): EthereumAddressInfo

  # Counts and other metrics
  count(uniq: SmartContractArgumentsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean): Int

  # Calendar date
  date: Date

  # External call executed explicitly by tx sender. Internal calls executed by smart contracts.
  external(external: Boolean): Boolean

  # Sequential index of value in array ( multi-dimensional)
  index: String!
  maximum(of: EthereumArgumentsMeasureable!, get: EthereumArgumentsMeasureable, as: EthereumArgumentsConvertable, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean): String
  minimum(of: EthereumArgumentsMeasureable!, get: EthereumArgumentsMeasureable, as: EthereumArgumentsConvertable, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean): String
  number(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean): Float

  # Address value of method or event argument
  reference(reference: [EthereumAddressSelector!]): EthereumAddressInfo

  # Smart contract being called
  smartContract(smartContractAddress: [EthereumAddressSelector!]): EthereumSmartContract

  # Contract method or event
  smartContractSignature(smartContractMethod: MethodSelector, smartContractEvent: EventSelector, signatureType: SignatureTypeSelector): Signature

  # True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  success(success: [Boolean!]): Boolean

  # Transaction where call happened
  transaction(txHash: [HashSelector!], txFrom: [EthereumAddressSelector!]): EthereumTransactionInfo

  # The Value of method or event argument
  value(value: [ArgumentValueSelector!]): ArgumentValue
}

enum EthereumArgumentsConvertable {
  # Token symbol
  token_symbol

  # Token name
  token_name
}

enum EthereumArgumentsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Caller
  caller

  # Smart Contract
  smart_contract

  # Smart Contract Method Name
  signature_name

  # Smart Contract Method Signature
  signature

  # Smart Contract Method Signature
  signature_type

  # Smart Contract Method Signature Hash
  signature_hash

  # Call depth
  call_depth

  # Argument
  argument

  # Argument type
  argument_type

  # Argument value
  argument_value

  # Argument index
  argument_index
}

# Balance in a currency
type EthereumBalance {
  # Currency of transfer
  currency: Currency

  # History of balance changes by currencies for the address
  history(currency: [EthereumCurrencySelector!], height: BlockSelectorRange): [EthereumBalanceChange!]
  value: Float
}

# Change of balance in a currency
type EthereumBalanceChange {
  # Block number (height) in blockchain
  block: Int!

  # Block timestamp
  timestamp: ISO8601DateTime

  # Transfer amount ( positive inbound, negative outbound)
  transferAmount: Float
  value: Float
}

input EthereumBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  miner: [EthereumAddressSelector!]
  blockReward: [AmountSelector!]
  transactionCount: [IntegerSelector!]
  uncleCount: [IntegerSelector!]
  size: [IntegerSelector!]
}

# Blocks in Ethereum blockchain
type EthereumBlocks {
  any(of: EthereumBlocksMeasureable!): String
  count(uniq: EthereumBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int

  # Calendar date
  date: Date
  difficulty(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Float

  # Block hash
  hash(blockHash: [HashSelector!]): String!

  # Block number (height) in blockchain
  height(height: BlockSelector): Int!
  maximum(of: EthereumBlocksMeasureable!, get: EthereumBlocksMeasureable): String

  # Block miner
  miner(miner: [EthereumAddressSelector!]): EthereumAddressInfo
  minimum(of: EthereumBlocksMeasureable!, get: EthereumBlocksMeasureable): String

  # Block nonce
  nonce: Int!

  # Parent block hash
  parentHash: String!
  reward(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Float

  # Currency of reward
  rewardCurrency: Currency
  size(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int

  # Block timestamp
  timestamp(time: DateTimeSelector): DateTime
  totalDifficulty(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Float
  transactionCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
  uncleCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
}

enum EthereumBlocksMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Block hash
  block_hash

  # Block Reward
  block_reward

  # Block Miner
  miner
}

enum EthereumBlocksUniq {
  # Unique miner count
  miners

  # Unique date count
  dates
}

enum EthereumCallsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Caller
  caller

  # Smart Contract
  smart_contract

  # Smart Contract Method Name
  signature_name

  # Smart Contract Method Signature
  signature

  # Smart Contract Method Signature Hash
  signature_hash

  # Call depth
  call_depth
}

# Coinpath
type EthereumCoinpath {
  # Summary of transfered value
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  # Block where transaction is included
  block: Block

  # Count of transfers
  count: Int

  # Currency of transfer
  currency: Currency

  # 1-based hop depth of the graph
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  # Receiver address
  receiver: EthereumAddressInfo

  # Sender address
  sender: EthereumAddressInfo

  # Transaction of transfer happened
  transaction: TransactionHashValue

  # Attributes of transaction included in Coinpath result
  transactions: [CoinpathEntry!]
}

# Currency selector in Ethereum blockchain.
#   Currencies supported are native ( ETH / ETC ), ERC20, ERC721 tokens.
#   You can specify currency symbol or smart contract address. Symbols ETH/ETC are
# reserved for native currencies in Ethereum mainnet and classic.
#   Ethereum Smart contract address should start from 0x and contain 40 hex digits.
#   If digits are case sensitive, address is checked against checksum according to EIP-55.
input EthereumCurrencySelector {
  # Currency is
  is: String

  # Currency not
  not: String

  # Currency in the list
  in: [String!]

  # Currency not in the list
  notIn: [String!]
}

# Ethereum DEX attributes
type EthereumDex {
  # Address for DEX exchange identification
  address: Address!

  # Full name ( name for known, Protocol for unknown )
  fullName: String!

  # Full name ( name for known, Protocol / address for unknown )
  fullNameWithId: String!

  # Name for known exchanges
  name: String
}

input EthereumDexTradeFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [EthereumAddressSelector!]
  protocol: [StringSelector!]
  smartContractAddress: [EthereumAddressSelector!]
  exchangeAddress: [EthereumAddressSelector!]
  exchangeName: [StringSelector!]
  sellCurrency: [EthereumCurrencySelector!]
  buyCurrency: [EthereumCurrencySelector!]
  baseCurrency: [EthereumCurrencySelector!]
  quoteCurrency: [EthereumCurrencySelector!]
  maker: [EthereumAddressSelector!]
  makerSmartContractType: [SmartContractTypeSelector!]
  taker: [EthereumAddressSelector!]
  takerSmartContractType: [SmartContractTypeSelector!]
  makerOrTaker: [EthereumAddressSelector!]
  tradeIndex: [StringSelector!]
  buyAmount: [AmountSelector!]
  sellAmount: [AmountSelector!]
  price: [AmountSelector!]
  priceAsymmetry: [FloatSelector!]
  tradeAmountUsd: [FloatSelector!]
}

# Trades on DEX smart contracts
type EthereumDexTrades {
  # Trader (maker or taker)
  address(makerOrTaker: [EthereumAddressSelector!]): EthereumAddressInfo
  any(of: EthereumDexTradesMeasureable!): String
  baseAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  # Base currency
  baseCurrency(baseCurrency: [EthereumCurrencySelector!]): Currency

  # Block in the blockchain
  block(height: BlockSelector, time: DateTimeSelector): BlockExtended
  buyAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  # Maker buys this currency
  buyCurrency(buyCurrency: [EthereumCurrencySelector!]): Currency
  count(uniq: EthereumDexTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Int

  # Calendar date
  date: Date

  # Identification of admin / manager / factory of smart contract, executing trades
  exchange(exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!]): EthereumDex
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float

  # Gas price in Gwei
  gasPrice(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float!
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  # Trade 'maker' side
  maker(maker: [EthereumAddressSelector!]): EthereumAddressInfo
  maximum(of: EthereumDexTradesMeasureable!, get: EthereumDexTradesMeasureable): String
  minimum(of: EthereumDexTradesMeasureable!, get: EthereumDexTradesMeasureable): String
  price(calculate: PriceAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float

  # Protocol name of the smart contract
  protocol(protocol: [StringSelector!]): String
  quoteAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  # Quote currency
  quoteCurrency(quoteCurrency: [EthereumCurrencySelector!]): Currency
  quotePrice(calculate: PriceAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float
  sellAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  # Maker sells this currency
  sellCurrency(sellCurrency: [EthereumCurrencySelector!]): Currency

  # Side of trade ( SELL / BUY )
  side: TradeSide

  # Smart contract being called
  smartContract(smartContractAddress: [EthereumAddressSelector!]): EthereumSmartContract

  # Trade 'taker' side
  taker(taker: [EthereumAddressSelector!]): EthereumAddressInfo

  # Time interval
  timeInterval: TimeInterval
  tradeAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum!): Float

  # Index of trade in transaction, used to separate trades in transaction
  tradeIndex(tradeIndex: [StringSelector!]): String

  # Transaction of DexTrade
  transaction(txHash: [HashSelector!], txSender: [EthereumAddressSelector!]): EthereumTransactionInfoExtended
}

enum EthereumDexTradesMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Buy Amount
  buy_amount

  # Sell Amount
  sell_amount

  # Price
  price

  # Quote Price
  quote_price

  # Maker
  maker

  # Taker
  taker

  # Buy Currency symbol
  buy_currency_symbol

  # Buy Token address
  buy_currency_address

  # Sell Currency symbol
  sell_currency_symbol

  # Sell Token address
  sell_currency_address
}

enum EthereumDexTradesUniq {
  # Unique TX senders count
  senders

  # Unique makers count
  makers

  # Unique makers count
  takers

  # Unique makers & takers count
  address

  # Buy currencies count
  buy_currency

  # Sell currencies count
  sell_currency

  # Base currencies count
  base_currency

  # Quote currencies count
  quote_currency

  # Unique blocks
  blocks

  # Unique transactions count
  txs

  # Unique date count
  dates

  # Unique smart contract count
  smart_contracts

  # Unique protocols count
  protocols
}

enum EthereumEventsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Smart Contract
  smart_contract

  # Smart Contract Event Name
  signature_name

  # Smart Contract Event Signature
  signature

  # Smart Contract Event Signature Hash
  signature_hash
}

enum EthereumNetwork {
  # Ethereum Mainnet
  ethereum

  # Ethereum Classic
  ethclassic

  # Ethereum Classic ( no reorg from block 10904146)
  ethclassic_reorg

  # Celo Alfajores Testnet
  celo_alfajores

  # Celo Baklava Testnet
  celo_baklava

  # Celo RC1
  celo_rc1

  # Binance Smart Chain Mainnet
  bsc

  # Binance Smart Chain Testnet
  bsc_testnet

  # Goerli Ethereum Testnet
  goerli
}

# Ethereum smart contract
type EthereumSmartContract {
  # Smart Contract Address
  address: Address!

  # Smart Contract Type
  contractType: SmartContractType

  # Token implemented in this smart contract
  currency: Currency

  # Smart Contract Protocol Type
  protocolType: String
}

input EthereumSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [EthereumAddressSelector!]
  caller: [EthereumAddressSelector!]
  smartContractAddress: [EthereumAddressSelector!]
  smartContractMethod: MethodSelector
  smartContractType: SmartContractTypeSelector
  external: Boolean
  success: [Boolean!]
}

# Smart Contract Calls
type EthereumSmartContractCalls {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, external: Boolean, success: [Boolean!]): Float
  any(of: EthereumCallsMeasureable!): String

  # Call arguments
  arguments: [ArgumentNameValue!]

  # Block in the blockchain
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Depth of the call. Empty string for external call, then counted as 0...N, and
  # the next layer is added through '-'. For example 0-3-9.
  callDepth: String

  # Caller of the method invocation ( tx sender or another smart contract )
  caller(caller: [EthereumAddressSelector!]): EthereumAddressInfo

  # Counts and other metrics
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, external: Boolean, success: [Boolean!]): Int

  # Calendar date
  date: Date

  # External call executed explicitly by tx sender. Internal calls executed by smart contracts.
  external(external: Boolean): Boolean

  # Gas used for transaction in external call, or by methd in internal call
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, external: Boolean, success: [Boolean!]): Float
  maximum(of: EthereumCallsMeasureable!, get: EthereumCallsMeasureable): String
  minimum(of: EthereumCallsMeasureable!, get: EthereumCallsMeasureable): String

  # Smart contract being called
  smartContract(smartContractAddress: [EthereumAddressSelector!]): EthereumSmartContract

  # Contract method invoked
  smartContractMethod(smartContractMethod: MethodSelector): Method

  # True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  success(success: [Boolean!]): Boolean

  # Transaction where call happened
  transaction(txHash: [HashSelector!], txFrom: [EthereumAddressSelector!]): EthereumTransactionInfo
}

# Smart Contract Events
type EthereumSmartContractEvent {
  any(of: EthereumEventsMeasureable!): String

  # Event arguments
  arguments: [ArgumentNameValue!]

  # Block in the blockchain
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Counts and other metrics
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], smartContractType: SmartContractTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector): Int

  # Calendar date
  date: Date

  # Event index
  eventIndex: String
  maximum(of: EthereumEventsMeasureable!, get: EthereumEventsMeasureable): String
  minimum(of: EthereumEventsMeasureable!, get: EthereumEventsMeasureable): String

  # Smart contract being called
  smartContract(smartContractAddress: [EthereumAddressSelector!]): EthereumSmartContract

  # Contract event logged
  smartContractEvent(smartContractEvent: EventSelector): Event

  # Transaction where event happened
  transaction(txHash: [HashSelector!], txFrom: [EthereumAddressSelector!]): EthereumTransactionInfo
}

input EthereumSmartContractEventFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [EthereumAddressSelector!]
  smartContractType: SmartContractTypeSelector
  smartContractAddress: [EthereumAddressSelector!]
  smartContractEvent: EventSelector
}

# Blockchain smart contract
type EthereumSmartContractInfo {
  # Smart Contract Type
  contractType: SmartContractType

  # Token implemented in this smart contract
  currency: Currency

  # Smart Contract Protocol Type
  protocolType: String
}

# Blockchain smart contract
type EthereumSmartContractInfoWithAttributes {
  # Attributes from readonly methods
  attributes: [SmartContractReadonlyAttribute!]

  # Smart Contract Type
  contractType: SmartContractType

  # Token implemented in this smart contract
  currency: Currency

  # Smart Contract Protocol Type
  protocolType: String
}

input EthereumTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [EthereumAddressSelector!]
  txTo: [EthereumAddressSelector!]
  txCreates: [EthereumAddressSelector!]
  txIndex: TxIndexSelector
  success: Boolean
  amount: [AmountSelector!]
  gasCurrency: [EthereumCurrencySelector!]
  gasValue: [AmountSelector!]
}

# Blockchain transaction info
type EthereumTransactionInfo {
  # Gas consumed
  gas: Int!

  # Gas price in Gwei
  gasPrice: Float!

  # Gas value cost
  gasValue: Float!

  # Hash hex representation
  hash: String!

  # Transaction from address
  txFrom: EthereumAddressInfo!
}

# Blockchain Transaction Extended info
type EthereumTransactionInfoExtended {
  # Gas consumed
  gas: Int!

  # Gas price in Gwei
  gasPrice: Float!

  # Gas value cost
  gasValue: Float!

  # Hash hex representation
  hash: String!

  # Transaction index in block, 0 based
  index: Int

  # Transaction nonce
  nonce: Int

  # Transaction receiver
  to: EthereumAddressInfo

  # Transaction from address
  txFrom: EthereumAddressInfo!
}

# Transactions in Ethereum blockchain
type EthereumTransactions {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!]): Float
  any(of: EthereumTransactionsMeasureable!): String

  # Block where transfer transaction is included
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: EthereumTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!]): Int

  # Created smart contract
  creates(txCreates: [EthereumAddressSelector!]): EthereumAddressInfo

  # Currency of amount
  currency: Currency

  # Calendar date
  date: Date

  # Error message if any
  error: String
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!]): Float

  # Currency of gas
  gasCurrency(gasCurrency: [EthereumCurrencySelector!]): Currency

  # Gas price in Gwei
  gasPrice(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!]): Float!
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!]): Float

  # Hash hex representation
  hash(txHash: [HashSelector!]): String!

  # Transaction index in block, 0 based
  index(txIndex: [TxIndexSelector!]): Int
  maximum(of: EthereumTransactionsMeasureable!, get: EthereumTransactionsMeasureable): String
  minimum(of: EthereumTransactionsMeasureable!, get: EthereumTransactionsMeasureable): String

  # Transaction nonce
  nonce: Int

  # Transaction sender
  sender(txSender: [EthereumAddressSelector!]): EthereumAddressInfo

  # Success
  success(success: Boolean): Boolean

  # Transaction receiver
  to(txTo: [EthereumAddressSelector!]): EthereumAddressInfo
}

enum EthereumTransactionsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Amount
  amount

  # Transaction Sender
  tx_sender

  # Gas value
  gas_value

  # Gas price
  gas_price

  # Gas used
  gas
}

enum EthereumTransactionsUniq {
  # Unique TX senders count
  senders

  # Unique TX receivers count
  receivers

  # Unique blocks
  blocks

  # Unique date count
  dates
}

input EthereumTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [EthereumAddressSelector!]
  entityId: EntitySelector
  sender: [EthereumAddressSelector!]
  receiver: [EthereumAddressSelector!]
  currency: [EthereumCurrencySelector!]
  external: Boolean
  amount: [AmountSelector!]
}

# Currency transfers from/to addresses in crypto currencies
type EthereumTransfers {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, amount: [AmountSelector!]): Float
  any(of: EthereumTransfersMeasureable!): String

  # Block where transfer transaction is included
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, amount: [AmountSelector!]): Int

  # Currency of transfer
  currency(currency: [EthereumCurrencySelector!]): Currency

  # Calendar date
  date: Date

  # Entity identifier ( for ERC-721 NFT tokens )
  entityId(entityId: EntitySelector): String

  # External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts.
  external(external: Boolean): Boolean
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, amount: [AmountSelector!]): Float
  maximum(of: EthereumTransfersMeasureable!, get: EthereumTransfersMeasureable): String
  minimum(of: EthereumTransfersMeasureable!, get: EthereumTransfersMeasureable): String

  # Transfer receiver
  receiver(receiver: [EthereumAddressSelector!]): EthereumAddressInfo

  # Transfer sender
  sender(sender: [EthereumAddressSelector!]): EthereumAddressInfo

  # Transaction where transfer happened
  transaction(txHash: [HashSelector!], txFrom: [EthereumAddressSelector!]): EthereumTransactionInfo
}

enum EthereumTransfersMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Amount
  amount

  # Sender
  sender

  # Receiver
  receiver

  # Currency symbol
  currency_symbol

  # Token address
  currency_address

  # Entity ID
  entity_id
}

# Smart contract event
type Event {
  # Name
  name: String

  # Signature
  signature: String

  # Signature Hash
  signatureHash: String!
}

# Smart contract event. In selector you can use the name, signature or hex hash
input EventSelector {
  # Event signature is
  is: String

  # Event signature not
  not: String

  # Event signature in the list
  in: [String!]

  # Event signature not in the list
  notIn: [String!]
}

# Filecoin
type Filecoin {
  # Filecoin Network Blocks
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector, any: [FilecoinBlockFilter!], options: QueryOptions): [FilecoinBlock!]

  # Filecoin Network Calls
  calls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, messageMethod: IntegerSelector, any: [FilecoinCallFilter!], options: QueryOptions): [FilecoinCalls!]

  # Money flow using Coinpath technology
  coinpath(sender: AddressSelector, receiver: AddressSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [FilecoinCoinpath!]

  # Filecoin Network Messages ( blocks, transfers, ... )
  messages(date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector, any: [FilecoinMessageFilter!], options: QueryOptions): [FilecoinMessages!]

  # Filecoin Network Currency Transfers
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, transferType: TransferTypeSelector, messageMethod: IntegerSelector, any: [FilecoinTransferFilter!], options: QueryOptions): [FilecoinTransfers!]
}

# Block
type FilecoinBlock {
  any(of: FilecoinBlocksMeasureable!): String
  blockSig: NameWithId
  blsAggregate: NameWithId
  count(uniq: FilecoinBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Int

  # Calendar date
  date: Date
  electionProof: String
  forkSignalling: BigInt

  # Block hash
  hash(blockHash: [HashSelector!]): String!

  # Block round in blockchain
  height(height: BlockSelector): Int!

  # Block index on height
  index(blockIndex: IntegerSelector): Int
  maximum(of: FilecoinBlocksMeasureable!, get: FilecoinBlocksMeasureable): String
  messageCount(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Int
  messages: String

  # Miner
  miner(miner: AddressSelector): Address
  minerTips(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Float
  minimum(of: FilecoinBlocksMeasureable!, get: FilecoinBlocksMeasureable): String
  parentMessageReceipts: String
  parentStateRoot: String
  parentWeight: BigInt
  reward(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Float
  ticket: String

  # Block timestamp
  timestamp(time: DateTimeSelector): DateTime
  totalReward(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Float
  winCount(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Int
  wincount: Int
}

input FilecoinBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  miner: [AddressSelector!]
  blockIndex: IntegerSelector
}

enum FilecoinBlocksMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Block hash
  block_hash

  # Block Miner
  miner
}

enum FilecoinBlockUniq {
  # Miner
  miners

  # Unique date count
  dates

  # Unique block height count
  heights

  # Unique block count
  blocks
}

input FilecoinCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  hash: HashSelector
  sender: AddressSelector
  receiver: AddressSelector
  method: IntegerSelector
  amount: AmountSelector
  messageMethod: IntegerSelector
}

# Calls in Filecoin blockchain
type FilecoinCalls {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, messageMethod: IntegerSelector): Float
  any(of: FilecoinCallsMeasureable!): String

  # Block where transfer Message is included
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Call hash
  callHash: String

  # Call hash
  callPath: String
  count(uniq: FilecoinMessagesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, messageMethod: IntegerSelector): Int

  # Calendar date
  date: Date
  exitCode: BigInt
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Int
  gasFeeCap: BigInt
  gasLimit: BigInt
  gasPremium: Float

  # Message hash
  hash(hash: HashSelector): String
  maximum(of: FilecoinCallsMeasureable!, get: FilecoinCallsMeasureable): String

  # Message Method
  messageMethod(messageMethod: IntegerSelector): NameWithId

  # Method
  method(method: IntegerSelector): NameWithId
  minedBlock: FilecoinMinedBlock
  minimum(of: FilecoinCallsMeasureable!, get: FilecoinCallsMeasureable): String
  nonce: BigInt

  # Message receiver
  receiver(receiver: AddressSelector): AddressWithAccount
  returnValue: String

  # Message sender
  sender(sender: AddressSelector): AddressWithAccount

  # Success
  success(success: Boolean): Boolean
}

enum FilecoinCallsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Message hash
  message_hash

  # Amount
  amount

  # Gas value
  gas_value

  # Gas limit
  gas_limit

  # Gas used
  gas
}

# Coinpath
type FilecoinCoinpath {
  # Summary of transfered value
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  # Block where transaction is included
  block: Block

  # Count of transfers
  count: BigInt

  # Currency of transfer
  currency: Currency

  # 1-based hop depth of the graph
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  # Message of transfer happened
  message: TransactionHashValue
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  # Receiver address
  receiver: Address

  # Sender address
  sender: Address
}

input FilecoinMessageFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  hash: HashSelector
  index: IntegerSelector
  sender: AddressSelector
  receiver: AddressSelector
  method: IntegerSelector
  success: Boolean
  amount: AmountSelector
}

# Messages in Filecoin blockchain
type FilecoinMessages {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  any(of: FilecoinMessagesMeasureable!): String
  baseFeeBurn(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float

  # Block where transfer Message is included
  block(height: BlockSelector, time: DateTimeSelector): Block
  burned(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  count(uniq: FilecoinMessagesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Int

  # Calendar date
  date: Date
  exitCode: BigInt
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Int
  gasFeeCap: BigInt
  gasLimit: BigInt
  gasPremium: Float

  # Message hash
  hash(hash: HashSelector): String
  maximum(of: FilecoinMessagesMeasureable!, get: FilecoinMessagesMeasureable): String

  # Method
  method(method: IntegerSelector): NameWithId
  minedBlock: FilecoinMinedBlock
  minerPenalty(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  minerTip(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  minimum(of: FilecoinMessagesMeasureable!, get: FilecoinMessagesMeasureable): String
  nonce: BigInt
  overEstimationBurn(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float

  # Message receiver
  receiver(receiver: AddressSelector): AddressWithAccount
  refund(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  returnValue: String

  # Message sender
  sender(sender: AddressSelector): AddressWithAccount
  signature: String
  signatureType: String

  # Signed Message hash
  signedHash: String

  # Success
  success(success: Boolean): Boolean
  totalCost(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
}

enum FilecoinMessagesMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Message hash
  message_hash

  # Amount
  amount

  # Gas value
  gas_value

  # Gas limit
  gas_limit

  # Gas used
  gas
}

enum FilecoinMessagesUniq {
  # Unique block heights
  blocks

  # Unique date count
  dates

  # Unique Message senders
  senders

  # Unique Message receivers
  receivers
}

# Filecoin Mined Block
type FilecoinMinedBlock {
  # Hash
  hash: String

  # Index on height
  index: Int

  # Miner
  miner: Address
}

enum FilecoinNetwork {
  # Filecoin Mainnet
  filecoin
}

input FilecoinTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  hash: HashSelector
  sender: AddressSelector
  receiver: AddressSelector
  method: IntegerSelector
  amount: AmountSelector
  transferType: TransferTypeSelector
  messageMethod: IntegerSelector
}

# Transfers in Filecoin blockchain
type FilecoinTransfers {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, transferType: TransferTypeSelector, messageMethod: IntegerSelector): Float
  any(of: FilecoinTransfersMeasureable!): String

  # Block where transfer Transfer is included
  block(height: BlockSelector, time: DateTimeSelector): BlockExtended

  # Call hash
  callHash: String

  # Call hash
  callPath: String
  count(uniq: FilecoinMessagesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, transferType: TransferTypeSelector, messageMethod: IntegerSelector): Int

  # Currency of transfer
  currency: Currency

  # Calendar date
  date: Date

  # Message hash
  hash(hash: HashSelector): String
  maximum(of: FilecoinTransfersMeasureable!, get: FilecoinTransfersMeasureable): String

  # Message Method
  messageMethod(messageMethod: IntegerSelector): NameWithId

  # Method
  method(method: IntegerSelector): NameWithId
  minimum(of: FilecoinTransfersMeasureable!, get: FilecoinTransfersMeasureable): String

  # Transfer receiver
  receiver(receiver: AddressSelector): Address

  # Transfer sender
  sender(sender: AddressSelector): Address

  # Transfer timestamp
  timestamp(time: DateTimeSelector): DateTime

  # Type of transfer
  transferType(transferType: TransferTypeSelector): FilecoinTransferType
}

enum FilecoinTransfersMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Block hash
  block_hash

  # Transfer hash
  tx_hash

  # Value
  value

  # Gas value
  gas_value

  # Gas limit
  gas_limit

  # Gas used
  gas
}

enum FilecoinTransferType {
  # Send (transfer)
  send

  # Miner Tip
  miner

  # Reward
  reward

  # Burn
  burn

  # Rebalance
  rebalance

  # Genesis
  genesis
}

# Select by number
input FloatSelector {
  # is
  is: Float

  # not
  not: Float

  # in the list
  in: [Float!]

  # not in the list
  notIn: [Float!]

  # greater than
  gt: Float

  # less than
  lt: Float

  # less or equal than
  lteq: Float

  # greater or equal than
  gteq: Float

  # in range
  between: [Float!]
}

enum FlowDirection {
  # Inbound transfers
  inbound

  # Outbound transfers
  outbound
}

# Select by hash
input HashSelector {
  # Hash is
  is: String

  # Hash not
  not: String

  # Hash in the list
  in: [String!]

  # Hash not in the list
  notIn: [String!]
}

# Input Script Type of UTXO transaction input
type InputScript {
  # Script annotation
  annotation: String

  # Long script pattern
  pattern: String!

  # Short script pattern
  shortPattern: String!

  # Simple script pattern
  simplePattern: String!

  # Script type
  type: BitcoinInputScriptType
}

# Select limited upper number
input IntegerLimitedSelector {
  # is
  is: Int

  # in the list
  in: [Int!]

  # less than
  lt: Int

  # less or equal than
  lteq: Int

  # in range
  between: [Int!]
}

# Select by number
input IntegerSelector {
  # is
  is: Int

  # not
  not: Int

  # in the list
  in: [Int!]

  # not in the list
  notIn: [Int!]

  # greater than
  gt: Int

  # less than
  lt: Int

  # less or equal than
  lteq: Int

  # greater or equal than
  gteq: Int

  # in range
  between: [Int!]
}

# Select by ID
input IntIdSelector {
  # ID is
  is: Int

  # ID not
  not: Int

  # ID in the list
  in: [Int!]

  # ID not in the list
  notIn: [Int!]

  # ID greater than
  gt: Int

  # ID less than
  lt: Int

  # ID less or equal than
  lteq: Int

  # ID greater or equal than
  gteq: Int

  # ID in range
  between: [Int!]
}

# An ISO 8601-encoded datetime
scalar ISO8601DateTime

# Libra
type Libra {
  # Libra Network Blocks
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, proposer: [AddressSelector!], metadata: StringSelector, any: [LibraBlockFilter!], options: QueryOptions): [LibraBlock!]

  # Money flow using Coinpath technology
  coinpath(sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [LibraCoinpath!]

  # Libra Network Currency Minting
  mints(date: DateSelector, time: DateTimeSelector, block: BlockSelector, version: IntegerSelector, minter: AddressSelector, currency: [LibraCurrencySelector!], amount: [AmountSelector!], any: [LibraMintFilter!], options: QueryOptions): [LibraMints!]

  # Libra Network Transactions
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector, any: [LibraTransactionFilter!], options: QueryOptions): [LibraTransactions!]

  # Libra Network Currency Transfers
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector, any: [LibraTransferFilter!], options: QueryOptions): [LibraTransfers!]
}

# Block
type LibraBlock {
  any(of: LibraBlocksMeasureable!): String
  count(uniq: LibraBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, proposer: [AddressSelector!], metadata: StringSelector): BigInt

  # Calendar date
  date: Date
  gasUsed(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, proposer: [AddressSelector!], metadata: StringSelector): Float

  # Block round in blockchain
  height(height: BlockSelector): Int!

  # Key
  key: String
  maximum(of: LibraBlocksMeasureable!, get: LibraBlocksMeasureable): String

  # Metadata
  metadata(metadata: StringSelector): String
  minimum(of: LibraBlocksMeasureable!, get: LibraBlocksMeasureable): String

  # Proposer
  proposer(proposer: AddressSelector): Address

  # Sequence number
  sequenceNumber: Int

  # Status Name
  statusName: String

  # Block timestamp
  timestamp(time: DateTimeSelector): DateTime

  # Version of transaction for this block
  version(version: IntegerSelector): Int!

  # Version hash of transaction for this block
  versionHash: String!

  # VM Status
  vmStatus: Int
}

input LibraBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  version: IntegerSelector
  proposer: [AddressSelector!]
  metadata: StringSelector
}

enum LibraBlocksMeasureable {
  # Date
  date

  # Time
  time

  # Block round
  block

  # Version
  version

  # Proposer
  proposer

  # Gas Used
  gas_used
}

enum LibraBlockUniq {
  # Proposer
  proposer

  # Unique date count
  dates
}

# Coinpath
type LibraCoinpath {
  # Summary of transfered value
  amount(in: BaseCurrencyEnum): Float
  any(of: LibraCoinpathMeasureable!): String

  # Block where transaction is included
  block: Block

  # Count of transfers
  count: BigInt

  # Currency of transfer
  currency: Currency

  # 1-based hop depth of the graph
  depth: Int
  maximum(of: LibraCoinpathMeasureable!, get: LibraCoinpathMeasureable): String
  minimum(of: LibraCoinpathMeasureable!, get: LibraCoinpathMeasureable): String

  # Receiver address
  receiver: Address

  # Sender address
  sender: Address

  # Transaction of transfer happened
  transaction: LibraTransactionValue
}

enum LibraCoinpathMeasureable {
  # Time
  time

  # Block
  block

  # Version
  version

  # Sender
  sender

  # Receiver
  receiver

  # Depth
  depth
}

# Currency selector in Libra blockchain.
# Libra has native chain currency (LBR) and a number of others ( Coin1/Coin2 ) for Testnet.
# Use name of currency for selection
input LibraCurrencySelector {
  # Currency is
  is: String

  # Currency not
  not: String

  # Currency in the list
  in: [String!]

  # Currency not in the list
  notIn: [String!]
}

input LibraMintFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  version: IntegerSelector
  minter: AddressSelector
  currency: [LibraCurrencySelector!]
  amount: [AmountSelector!]
}

# Mints in Libra blockchain
type LibraMints {
  amount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, block: BlockSelector, version: IntegerSelector, minter: AddressSelector, currency: [LibraCurrencySelector!], amount: [AmountSelector!]): Float
  any(of: LibraMintsMeasureable!): String

  # Block where transfer transaction is included
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: LibraMintsUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, version: IntegerSelector, minter: AddressSelector, currency: [LibraCurrencySelector!], amount: [AmountSelector!]): BigInt

  # Currency of transfer
  currency(currency: [LibraCurrencySelector!]): Currency

  # Calendar date
  date: Date
  maximum(of: LibraMintsMeasureable!, get: LibraMintsMeasureable): String
  minimum(of: LibraMintsMeasureable!, get: LibraMintsMeasureable): String

  # Minter
  minter(sender: AddressSelector): Address

  # Sequence number
  sequenceNumber: Int

  # Status Name
  statusName: String

  # Success
  success(success: Boolean): Boolean

  # Mint timestamp
  timestamp(time: DateTimeSelector): DateTime

  # Version of blockchain for this transaction
  version(version: IntegerSelector): Int!

  # Version hash of blockchain for this transaction
  versionHash: String!

  # VM Status
  vmStatus: Int
}

enum LibraMintsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Version
  version

  # Mint version hash
  version_hash

  # Amount
  amount

  # Minter
  minter

  # Currency symbol
  currency_symbol
}

enum LibraMintsUniq {
  # Unique blocks
  blocks

  # Unique versions
  versions

  # Unique date count
  dates

  # Unique minters
  minters

  # Unique currencies
  currencies
}

input LibraTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  version: IntegerSelector
  txSender: AddressSelector
  scriptType: ScriptTypeSelectorSelector
  success: Boolean
  gasCurrency: [LibraCurrencySelector!]
  scriptHash: StringSelector
}

# Transactions in Libra blockchain
type LibraTransactions {
  any(of: LibraTransactionsMeasureable!): String

  # Block where transfer transaction is included
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: LibraTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector): BigInt

  # Calendar date
  date: Date

  # Expiration Time
  expirationTime: DateTime
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector): Int

  # Currency of gas
  gasCurrency(gasCurrency: [LibraCurrencySelector!]): Currency

  # Gas unit price
  gasPrice(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector): Float!
  gasValue(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector): Float

  # Max gas amount
  maxGasAmount: Int
  maximum(of: LibraTransactionsMeasureable!, get: LibraTransactionsMeasureable): String
  minimum(of: LibraTransactionsMeasureable!, get: LibraTransactionsMeasureable): String

  # Public key
  publicKey: String

  # Script Hash
  scriptHash(scriptHash: StringSelector): String

  # Script Type
  scriptType: ScriptTypeSelectorSelector

  # Transaction sender
  sender(txSender: AddressSelector): Address

  # Sequence number
  sequenceNumber: Int

  # Signature
  signature: String

  # Signature scheme
  signatureScheme: String

  # Status Name
  statusName: String

  # Success
  success(success: Boolean): Boolean

  # Transaction timestamp
  timestamp(time: DateTimeSelector): DateTime

  # Version of blockchain for this transaction
  version(version: IntegerSelector): Int!

  # Version hash of blockchain for this transaction
  versionHash: String!

  # VM Status
  vmStatus: Int
}

enum LibraTransactionsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Version
  version

  # Transaction Sender
  tx_sender

  # Script Hash
  script_hash

  # Gas price
  gas_price

  # Gas used
  gas
}

enum LibraTransactionsUniq {
  # Unique blocks
  blocks

  # Unique versions
  versions

  # Unique date count
  dates

  # Unique transaction senders
  senders

  # Unique transaction script hashes
  scripts
}

# Blockchain transaction with value
type LibraTransactionValue {
  # Transaction value
  value: Float!

  # Transaction version
  version: Int!
}

input LibraTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  version: IntegerSelector
  txSender: AddressSelector
  sender: AddressSelector
  receiver: AddressSelector
  currency: [LibraCurrencySelector!]
  gasCurrency: [LibraCurrencySelector!]
  amount: [AmountSelector!]
  scriptType: ScriptTypeSelectorSelector
  scriptHash: StringSelector
}

# Transfers in Libra blockchain
type LibraTransfers {
  amount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector): Float
  any(of: LibraTransfersMeasureable!): String

  # Block where transfer transaction is included
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector): BigInt

  # Currency of transfer
  currency(currency: [LibraCurrencySelector!]): Currency

  # Calendar date
  date: Date

  # Expiration Time
  expirationTime: DateTime
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector): Int

  # Currency of gas
  gasCurrency(gasCurrency: [LibraCurrencySelector!]): Currency

  # Gas price
  gasPrice: Float!
  gasValue(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector): Float

  # Max gas amount
  maxGasAmount: Int
  maximum(of: LibraTransfersMeasureable!, get: LibraTransfersMeasureable): String
  minimum(of: LibraTransfersMeasureable!, get: LibraTransfersMeasureable): String

  # Public key
  publicKey: String

  # Transfer receiver
  receiver(receiver: AddressSelector): Address

  # Script Hash
  scriptHash(scriptHash: StringSelector): String

  # Script Type
  scriptType: ScriptTypeSelectorSelector

  # Transfer sender
  sender(sender: AddressSelector): Address

  # Sequence number
  sequenceNumber: Int

  # Signature
  signature: String

  # Signature scheme
  signatureScheme: String

  # Status Name
  statusName: String

  # Success
  success(success: Boolean): Boolean

  # Transfer timestamp
  timestamp(time: DateTimeSelector): DateTime

  # Transaction sender
  txSender(txSender: AddressSelector): Address

  # Version of blockchain for this transaction
  version(version: IntegerSelector): Int!

  # Version hash of blockchain for this transaction
  versionHash: String!

  # VM Status
  vmStatus: Int
}

enum LibraTransfersMeasureable {
  # Date
  date

  # Time
  time

  # Block
  height

  # Version
  version

  # Version hash
  version_hash

  # Amount
  amount

  # Transfer Sender
  tx_sender

  # Sender
  sender

  # Receiver
  receiver

  # Script Hash
  script_hash

  # Currency symbol
  currency_symbol

  # Gas value
  gas_value

  # Gas price
  gas_price

  # Gas used
  gas
}

# Limit by definition
input LimitByOption {
  # Take limit for each combination of the field
  each: String!

  # Limit number of results
  limit: Int

  # Offset of results, starting from 0
  offset: Int
}

# Smart contract method
type Method {
  # Name
  name: String

  # Signature
  signature: String

  # Signature Hash
  signatureHash: String!
}

# Smart contract method. In selector you can use the name, signature or hex hash
input MethodSelector {
  # Method signature is
  is: String

  # Method signature not
  not: String

  # Method signature in the list
  in: [String!]

  # Method signature not in the list
  notIn: [String!]
}

# Name with an identifier
type NameWithId {
  # ID
  id: Int

  # Name
  name: String
}

enum Network {
  # Ethereum Mainnet
  ethereum

  # Ethereum Classic
  ethclassic

  # Ethereum Classic ( no reorg from block 10904146)
  ethclassic_reorg

  # Binance DEX
  binance

  # Celo Alfajores Testnet
  celo_alfajores

  # Celo Baklava Testnet
  celo_baklava

  # Celo RC1
  celo_rc1

  # Bitcoin ( BTC )
  bitcoin

  # Bitcoin Cash ( BCH )
  bitcash

  # Bitcoin SV ( BSV )
  bitcoinsv

  # Litecoin ( LTC )
  litecoin

  # Dash ( DASH )
  dash

  # Dogecoin ( DOGE )
  dogecoin

  # Cardano ( ADA )
  cardano

  # Zcash ( ZEC )
  zcash

  # Algorand Mainnet (ALGO)
  algorand

  # Algorand Testnet
  algorand_testnet

  # Algorand Betanet
  algorand_betanet

  # Conflux Oceanus
  conflux_oceanus

  # Conflux Tethys
  conflux_tethys

  # Libra Testnet
  libra_testnet

  # Diem Testnet
  diem_testnet

  # EOS Mainnet
  eos

  # Tron Mainnet
  tron

  # Binance Smart Chain Mainnet
  bsc

  # Binance Smart Chain Testnet
  bsc_testnet

  # Goerli Ethereum Testnet
  goerli

  # Beacon Chain Ethereum 2.0
  eth2

  # Medalla Ethereum 2.0 Beacon Testnet
  medalla

  # Filecoin Mainnet
  filecoin
}

# Offchain Data
type Offchain {
  # Historical COVID data
  covid: CovidHistory
}

# Select order by ID
input OrderIdSelector {
  # Order ID is
  is: String

  # Order ID not
  not: String

  # Order ID in the list
  in: [String!]

  # Order ID not in the list
  notIn: [String!]
}

# Select by order side
input OrderSideSelector {
  # Order Side is
  is: BinanceOrderSide

  # Order Side not
  not: BinanceOrderSide

  # Order Side in the list
  in: [BinanceOrderSide!]

  # Order Side not in the list
  notIn: [BinanceOrderSide!]
}

# Select by order status
input OrderStatusSelector {
  # Order Status is
  is: BinanceOrderStatus

  # Order Status not
  not: BinanceOrderStatus

  # Order Status in the list
  in: [BinanceOrderStatus!]

  # Order Status not in the list
  notIn: [BinanceOrderStatus!]
}

# Select by order time in force
input OrderTimeInForceSelector {
  # Order TimeInForce is
  is: BinanceOrderTimeInForce

  # Order TimeInForce not
  not: BinanceOrderTimeInForce

  # Order TimeInForce in the list
  in: [BinanceOrderTimeInForce!]

  # Order TimeInForce not in the list
  notIn: [BinanceOrderTimeInForce!]
}

# Select by order type
input OrderTypeSelector {
  # Order Type is
  is: BinanceOrderType

  # Order Type not
  not: BinanceOrderType

  # Order Type in the list
  in: [BinanceOrderType!]

  # Order Type not in the list
  notIn: [BinanceOrderType!]
}

# Select by output index ( o based )
input OutputIndexSelector {
  # Output index is
  is: Int

  # Output index not
  not: Int

  # Output index in the list
  in: [Int!]

  # Output index not in the list
  notIn: [Int!]

  # Output index greater than
  gt: Int

  # Output index less than
  lt: Int

  # Output index less or equal than
  lteq: Int

  # Output index greater or equal than
  gteq: Int

  # Output index in range
  between: [Int!]
}

# Output Script Type of UTXO transaction output
type OutputScript {
  # Script annotation
  annotation: String

  # Long script pattern
  pattern: String!

  # Short script pattern
  short: String!

  # Simple script pattern
  simplePattern: String!

  # Script type
  type: BitcoinOutputScriptType
}

enum PriceAggregateFunction {
  # Maximum
  maximum

  # Minimum
  minimum

  # Aggregated over interval
  sum

  # Average
  average

  # Median
  median

  # Any value
  any

  # Last value
  anyLast
}

enum Protocol {
  # Ethereum
  ethereum

  # Binance DEX
  binance

  # Bitcoin
  bitcoin

  # Algorand
  algorand

  # Libra
  libra

  # EOS
  eos

  # Tron
  tron

  # Filecoin
  filecoin
}

# Blockchain Unified GraphQL API
type Query {
  # Algorand Chains Dataset
  algorand(network: AlgorandNetwork): Algorand

  # Binance DEX Chain Dataset
  binance: Binance

  # Bitcoin and other UTXO Chains Dataset
  bitcoin(network: BitcoinNetwork): Bitcoin

  # Conflux Chains Dataset
  conflux(network: ConfluxNetwork): Conflux

  # Diem ( former Libra ) Testnet Dataset
  diem(network: DiemNetwork): Libra

  # EOS Mainnet Dataset
  eos: Eos

  # Ethereum Mainnet / Classic Chain Datasets
  ethereum(network: EthereumNetwork): Ethereum

  # Ethereum v2.0 Beacon Chain Datasets
  ethereum2(network: Ethereum2Network): Ethereum2

  # Filecoin Dataset
  filecoin(network: FilecoinNetwork): Filecoin

  # Offchain data
  offchain: Offchain

  # Search by query string
  search(string: String!, limit: Int, offset: Int, network: Network): [Result!]

  # Tron Mainnet Dataset
  tron: Tron
}

# Limits, Ordering, Constraints
input QueryOptions {
  # Limit number of results
  limit: Int

  # Limit number of results by specific field
  limitBy: LimitByOption

  # Offset of results, starting from 0
  offset: Int

  # Ordering field(s) for ascending
  asc: [String!]

  # Ordering field(s) for descending
  desc: [String!]
}

# Search result item
type Result {
  # Blockchain where result is found
  network: BlockchainNetwork!

  # Subject in blockchain
  subject: Subject!
}

enum ScriptTypeSelectorSelector {
  # Unknown Transaction
  unknown_transaction

  # Peer-to-peer
  peer_to_peer_transaction
}

# Smart contract method or event
union Signature = Event | Method

enum SignatureTypeSelector {
  # Smart contract method
  Function

  # Smart contract event
  Event
}

# Blockchain smart contract
type SmartContract {
  # String address representation
  address: String!

  # Annotations ( tags ), if exists
  annotation: String

  # Smart Contract Type
  contractType: SmartContractType!

  # Smart Contract Protocol Type
  protocol: String
}

enum SmartContractArgumentsUniq {
  # Unique signatures count
  signatures

  # Unique values
  values

  # Calls or events
  calls

  # Unique transactions count
  txs

  # Unique transaction senders
  senders

  # Unique callers count
  callers

  # Unique smart contracts count
  smart_contracts

  # Unique blocks
  blocks

  # Unique date count
  dates
}

enum SmartContractCallsUniq {
  # Calls
  calls

  # Unique transactions count
  txs

  # Unique transaction senders
  senders

  # Unique callers count
  callers

  # Unique smart contracts count
  smart_contracts

  # Unique smart contract methods count
  smart_contract_methods

  # Unique blocks
  blocks

  # Unique date count
  dates
}

type SmartContractReadonlyAttribute {
  # Value as address if applicable
  address: EthereumAddressInfo

  # Method name
  name: String!

  # Method return type
  type: String!

  # Method return value
  value: String!
}

enum SmartContractType {
  # Not A Smart contract
  None

  # General Purpose Smart contract
  Generic

  # Smart contract for token derivatives
  MarginPositionToken

  # Multi signature wallet
  Multisig

  # Token
  Token

  # Token Sale
  TokenSale

  # Decentralized exchange
  DEX

  # Transaction Execution Approval Language
  TEAL
}

# Selector of smart contract type
input SmartContractTypeSelector {
  # Smart Contract type is
  is: SmartContractType

  # Smart Contract type not
  not: SmartContractType

  # Smart Contract type in the list
  in: [SmartContractType!]

  # Smart Contract type not in the list
  notIn: [SmartContractType!]
}

# Select by ID
input StringIdSelector {
  # ID is
  is: String

  # ID not
  not: String

  # ID in the list
  in: [String!]

  # ID not in the list
  notIn: [String!]
}

# Select by string
input StringSelector {
  # String is
  is: String

  # String not
  not: String

  # String in the list
  in: [String!]

  # String not in the list
  notIn: [String!]
}

# Search result subject
union Subject = Address | Currency | SmartContract | TransactionHash

# Time Interval
type TimeInterval {
  day(count: Int, format: String): String!
  hour(count: Int, format: String): String!
  minute(count: Int, format: String): String!
  month(count: Int, format: String): String!
  second(count: Int, format: String): String!
  year(count: Int, format: String): String!
}

# Select trade by ID
input TradeIdSelector {
  # Trade ID is
  is: String

  # Trade ID not
  not: String

  # Trade ID in the list
  in: [String!]

  # Trade ID not in the list
  notIn: [String!]
}

enum TradeSide {
  # Buy side
  BUY

  # Sell side
  SELL
}

# Blockchain transaction
type TransactionHash {
  # Hash hex representation
  hash: String!
}

# Blockchain transaction
type TransactionHashIndex {
  # Hash hex representation
  hash: String!

  # Transaction index in block, 0-based
  index: String!
}

# Blockchain transaction
type TransactionHashIndexValues {
  # Hash hex representation
  hash: String!

  # Transaction index in block, 0-based
  index: String!

  # Transaction value in input
  valueIn: Float!

  # Transaction value in output
  valueOut: Float!
}

# Blockchain transaction with value
type TransactionHashValue {
  # Hash hex representation
  hash: String!

  # Transaction value
  value: Float!
}

# Identification of transaction source as client application
type TransactionSource {
  # ID numeric
  code: Int!

  # Name
  name: String!
}

enum TransfersUniq {
  # Transfers
  transfers

  # Unique transactions count
  txs

  # Unique senders count
  senders

  # Unique receivers count
  receivers

  # Unique blocks
  blocks

  # Unique date count
  dates

  # Unique currencies
  currencies
}

# Select by type of transfer
input TransferTypeSelector {
  # Transfer Type is
  is: FilecoinTransferType

  # Transfer Type not
  not: FilecoinTransferType

  # Transfer Type in the list
  in: [FilecoinTransferType!]

  # Transfer Type not in the list
  notIn: [FilecoinTransferType!]
}

# Tron Chain
type Tron {
  # Basic information about address ( or smart contract )
  address(address: [AddressSelectorIn!]!): [TronAddressInfo!]!

  # Blockchain Blocks
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, witness: AddressSelector, version: IntegerSelector, parentBlockHash: [HashSelector!], any: [TronBlockFilter!], options: QueryOptions): [TronBlocks!]

  # Money flow using Coinpath technology
  coinpath(sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [TronCoinpath!]

  # Blockchain Embedded Contracts
  contracts(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean, any: [TronContractFilter!], options: QueryOptions): [TronSmartContracts!]

  # Smart Contract Calls
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean, any: [TronSmartContractCallFilter!], options: QueryOptions): [TronSmartContractCalls!]

  # Smart Contract Events
  smartContractEvents(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractEvent: EventSelector, any: [TronSmartContractEventFilter!], options: QueryOptions): [TronSmartContractEvents!]

  # Blockchain Embedded Contracts
  trades(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean, any: [TronTradeFilter!], options: QueryOptions): [TronTrades!]

  # Blockchain Transactions
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector, any: [TronTransactionFilter!], options: QueryOptions): [TronTransactions!]

  # Currency Transfers
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!], any: [TronTransferFilter!], options: QueryOptions): [TronTransfers!]
}

# Address detailed information for Tron network
type TronAddressInfo {
  # String address representation
  address: String!

  # Annotations ( tags ), if exists
  annotation: String

  # Smart Contract if exists on the address
  smartContract: TronSmartContractInfo
}

input TronBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  witness: AddressSelector
  version: IntegerSelector
  parentBlockHash: [HashSelector!]
}

# Blocks in Tron blockchain
type TronBlocks {
  any(of: TronBlocksMeasureable!): String
  count(uniq: TronBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, witness: AddressSelector, version: IntegerSelector, parentBlockHash: [HashSelector!]): Int

  # Calendar date
  date: Date

  # Block hash
  hash(blockHash: [HashSelector!]): String!

  # Block number (height) in blockchain
  height(height: BlockSelector): Int!
  maximum(of: TronBlocksMeasureable!, get: TronBlocksMeasureable): String
  minimum(of: TronBlocksMeasureable!, get: TronBlocksMeasureable): String

  # Parent block hash
  parentBlockHash(parentBlockHash: [HashSelector!]): String!

  # Block timestamp
  timestamp(time: DateTimeSelector): DateTime

  # TX Trie Root Hash
  txTrieRoot: String!

  # Block version
  version(version: IntegerSelector): Int

  # Block witness
  witness(witness: AddressSelector): Address

  # Witness signature
  witnessSignature: String!
}

enum TronBlocksMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Block hash
  block_hash

  # Block Witness address
  witness

  # Block Version
  version
}

enum TronBlocksUniq {
  # Unique witness count
  witnesses

  # Unique date count
  dates
}

enum TronCallsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Action From
  tx_from

  # Action To
  tx_to

  # Smart Contract
  smart_contract

  # Smart Contract Method Name
  signature_name

  # Smart Contract Method Signature
  signature

  # Smart Contract Method Signature Hash
  signature_hash

  # Call depth
  call_depth
}

# Coinpath
type TronCoinpath {
  # Summary of transfered value
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  # Block where transaction is included
  block: Block

  # Count of transfers
  count: Int

  # Currency of transfer
  currency: Currency

  # 1-based hop depth of the graph
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  # Receiver address
  receiver: TronAddressInfo

  # Sender address
  sender: TronAddressInfo

  # Transaction of transfer happened
  transaction: TransactionHashValue
}

input TronContractFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txOwner: AddressSelector
  contractType: TronContractTypeSelector
  currency: TronCurrencySelector
  success: Boolean
}

enum TronContractsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Transaction owner
  tx_owner

  # Contract
  contract_type
}

enum TronContractType {
  # Account Create
  AccountCreate

  # Account Permission Update
  AccountPermissionUpdate

  # Account Update
  AccountUpdate

  # Asset Issue
  AssetIssue

  # Clear ABI
  ClearABI

  # Create Smart
  CreateSmart

  # Exchange Create
  ExchangeCreate

  # Exchange Inject
  ExchangeInject

  # Exchange Transaction
  ExchangeTransaction

  # Exchange Withdraw
  ExchangeWithdraw

  # Freeze Balance
  FreezeBalance

  # Participate Asset Issue
  ParticipateAssetIssue

  # Proposal Approve
  ProposalApprove

  # Proposal Create
  ProposalCreate

  # Proposal Delete
  ProposalDelete

  # Set Account Id
  SetAccountId

  # Transfer
  Transfer

  # Transfer Asset
  TransferAsset

  # Trigger Smart
  TriggerSmart

  # Unfreeze Asset
  UnfreezeAsset

  # Unfreeze Balance
  UnfreezeBalance

  # Update Asset
  UpdateAsset

  # Update Brokerage
  UpdateBrokerage

  # Update Energy Limit
  UpdateEnergyLimit

  # Update Setting
  UpdateSetting

  # Vote Witness
  VoteWitness

  # Withdraw Balance
  WithdrawBalance

  # Witness Create
  WitnessCreate

  # Witness Update
  WitnessUpdate
}

# Select contract type(s)
input TronContractTypeSelector {
  # Contract type is
  is: TronContractType

  # Contract type not
  not: TronContractType

  # Contract type in the list
  in: [TronContractType!]

  # Contract type not in the list
  notIn: [TronContractType!]
}

# Currency selector in Tron blockchain.
# Token identified by address of contract for TRC20 tokens and token name (or numeric token ID )  for TRC10
input TronCurrencySelector {
  # Currency is
  is: String

  # Currency not
  not: String

  # Currency in the list
  in: [String!]

  # Currency not in the list
  notIn: [String!]
}

enum TronEventsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Action From
  tx_from

  # Action To
  tx_to

  # Smart Contract
  smart_contract

  # Smart Contract Method Name
  signature_name

  # Smart Contract Method Signature
  signature

  # Smart Contract Method Signature Hash
  signature_hash
}

# Tron smart contract
type TronSmartContract {
  # Smart Contract Address
  address: Address!

  # Smart Contract Type
  contractType: SmartContractType

  # Token implemented in this smart contract
  currency: Currency

  # Smart Contract Protocol Type
  protocolType: String
}

input TronSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  smartContractAddress: AddressSelector
  smartContractMethod: MethodSelector
  external: Boolean
  success: Boolean
}

# Smart Contract Calls
type TronSmartContractCalls {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float
  any(of: TronCallsMeasureable!): String

  # Block in the blockchain
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Depth of the call. Empty string for external call, then counted as 0...N, and
  # the next layer is added through '-'. For example 0-3-9.
  callDepth: String

  # Counts and other metrics
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Int

  # Calendar date
  date: Date
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float

  # External call executed explicitly by caller. Internal calls executed by smart contracts.
  external(external: Boolean): Boolean
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float
  maximum(of: TronCallsMeasureable!, get: TronCallsMeasureable): String
  minimum(of: TronCallsMeasureable!, get: TronCallsMeasureable): String
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float

  # Smart contract being called
  smartContract(smartContractAddress: AddressSelector): TronSmartContract

  # Contract method invoked
  smartContractMethod(smartContractMethod: MethodSelector): Method

  # True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  success(success: [Boolean!]): Boolean

  # Action from address
  txFrom(txFrom: AddressSelector): Address

  # Transaction hash where transfer happened
  txHash(txHash: HashSelector): String

  # Action to address
  txTo(txTo: AddressSelector): Address
}

input TronSmartContractEventFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  smartContractAddress: AddressSelector
  smartContractEvent: EventSelector
}

# Smart Contract Events
type TronSmartContractEvents {
  any(of: TronEventsMeasureable!): String

  # Block in the blockchain
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Counts and other metrics
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractEvent: EventSelector): Int

  # Calendar date
  date: Date
  maximum(of: TronEventsMeasureable!, get: TronEventsMeasureable): String
  minimum(of: TronEventsMeasureable!, get: TronEventsMeasureable): String

  # Smart contract being Evented
  smartContract(smartContractAddress: AddressSelector): TronSmartContract

  # Contract method invoked
  smartContractEvent(smartContractEvent: EventSelector): Event

  # Action from address
  txFrom(txFrom: AddressSelector): Address

  # Transaction hash where transfer happened
  txHash(txHash: HashSelector): String

  # Action to address
  txTo(txTo: AddressSelector): Address
}

# Blockchain smart contract
type TronSmartContractInfo {
  # Smart Contract Type
  contractType: SmartContractType

  # Token implemented in this smart contract
  currency: Currency

  # Smart Contract Protocol Type
  protocolType: String
}

# Contracts
type TronSmartContracts {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): Float
  any(of: TronContractsMeasureable!): String

  # Block in the blockchain
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Contract type
  contractType(contractType: TronContractTypeSelector): TronContractType

  # Counts and other metrics
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): Int

  # Currency of transfer
  currency(currency: TronCurrencySelector): Currency

  # Calendar date
  date: Date
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): Float
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): Float
  maximum(of: TronContractsMeasureable!, get: TronContractsMeasureable): String
  minimum(of: TronContractsMeasureable!, get: TronContractsMeasureable): String
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): Float

  # True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  success(success: [Boolean!]): Boolean

  # Transaction hash where transfer happened
  txHash(txHash: HashSelector): String

  # Transactio owner from address
  txOwner(txOwner: AddressSelector): Address
}

input TronTradeFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  buyer: AddressSelector
  seller: AddressSelector
  buyCurrency: TronCurrencySelector
  sellCurrency: TronCurrencySelector
  contractType: TronContractTypeSelector
  amountSell: [AmountSelector!]
  amountBuy: [AmountSelector!]
  exchangeId: IntIdSelector
  success: Boolean
}

# Currency Trades from/to addresses in crypto currencies
type TronTrades {
  amountBuy(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Float
  amountSell(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Float
  any(of: TronTradesMeasureable!): String

  # Block where Trade transaction is included
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Buy Currency of Trade
  buyCurrency(buyCurrency: TronCurrencySelector): Currency

  # Trade buyer
  buyer(buyer: AddressSelector): Address

  # Contract type
  contractType(contractType: TronContractTypeSelector): TronContractType
  count(uniq: TronTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Int

  # Calendar date
  date: Date
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Float

  # exchange_id
  exchangeId(exchangeId: IntIdSelector): Int
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Float
  maximum(of: TronTradesMeasureable!, get: TronTradesMeasureable): String
  minimum(of: TronTradesMeasureable!, get: TronTradesMeasureable): String
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Float

  # Sell Currency of Trade
  sellCurrency(sellCurrency: TronCurrencySelector): Currency

  # Trade seller
  seller(seller: AddressSelector): Address

  # Transfer succeeded
  success(success: Boolean): Boolean

  # Transaction hash where Trade happened
  txHash(txHash: HashSelector): String
}

enum TronTradesMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Amount Sell
  amount_sell

  # Amount Sell
  amount_buy

  # Buyer
  buyer

  # Seller
  seller

  # Buy Currency symbol
  buy_currency_symbol

  # Buy Currency name
  buy_currency_name

  # Buy Token address
  buy_currency_address

  # Buy Token address
  buy_token_id

  # Buy Token type
  buy_token_type

  # Buy Currency symbol
  sell_currency_symbol

  # Buy Currency name
  sell_currency_name

  # Buy Token address
  sell_currency_address

  # Buy Token address
  sell_token_id

  # Buy Token type
  sell_token_type

  # Exchange ID
  exchange_id

  # Contract Type
  contract_type
}

enum TronTradesUniq {
  # Unique blocks
  blocks

  # Unique date count
  dates

  # Sellers count
  sellers

  # Buyers count
  buyers

  # Buy currencies
  buy_currencies

  # Sell currencies
  sell_currencies

  # Exchange IDs
  exchanges
}

input TronTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: TxIndexSelector
  success: Boolean
  refBlockHash: [HashSelector!]
  contractAddress: AddressSelector
}

# Transactions in Tron blockchain
type TronTransactions {
  any(of: TronTransactionsMeasureable!): String

  # Block where transfer transaction is included
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Contract Address
  contractAddress(contractAddress: AddressSelector): Address
  count(uniq: TronTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Int

  # Calendar date
  date: Date
  energyFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Float
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Float

  # Expiration
  expiration: Int!
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Float

  # Fee Limit
  feeLimit: Int!

  # Hash hex representation
  hash(txHash: [HashSelector!]): String!

  # Transaction index in block, 0 based
  index(txIndex: [TxIndexSelector!]): Int
  internalTransactionsCount(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Int
  logsCount(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Int
  maximum(of: TronTransactionsMeasureable!, get: TronTransactionsMeasureable): String
  minimum(of: TronTransactionsMeasureable!, get: TronTransactionsMeasureable): String
  netFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Float
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Float

  # Ref block Hash hex representation
  refBlockHash(refBlockHash: [HashSelector!]): String!

  # Result message
  result: String

  # Signatures
  signatures: String!

  # Success
  success(success: Boolean): Boolean
}

enum TronTransactionsMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Fee
  fee

  # Fee Limit
  fee_limit

  # Energy Fee
  energy_fee

  # Net usage
  net_usage

  # Internal transactions count
  internal_transactions_count
}

enum TronTransactionsUniq {
  # Unique blocks
  blocks

  # Unique date count
  dates
}

input TronTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  sender: AddressSelector
  receiver: AddressSelector
  currency: TronCurrencySelector
  contractType: TronContractTypeSelector
  entityId: EntitySelector
  external: Boolean
  success: Boolean
  amount: [AmountSelector!]
}

# Currency transfers from/to addresses in crypto currencies
type TronTransfers {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Float
  any(of: TronTransfersMeasureable!): String

  # Block where transfer transaction is included
  block(height: BlockSelector, time: DateTimeSelector): Block

  # Contract type
  contractType(contractType: TronContractTypeSelector): TronContractType
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Int

  # Currency of transfer
  currency(currency: TronCurrencySelector): Currency

  # Calendar date
  date: Date
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Float

  # Entity identifier ( for ERC-721 NFT tokens )
  entityId(entityId: EntitySelector): String

  # External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts.
  external(external: Boolean): Boolean
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Float
  maximum(of: TronTransfersMeasureable!, get: TronTransfersMeasureable): String
  minimum(of: TronTransfersMeasureable!, get: TronTransfersMeasureable): String
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Float

  # Transfer receiver
  receiver(receiver: AddressSelector): Address

  # Transfer sender
  sender(sender: AddressSelector): Address

  # Transfer succeeded
  success(success: Boolean): Boolean

  # Action from address
  txFrom(txFrom: AddressSelector): Address

  # Transaction hash where transfer happened
  txHash(txHash: HashSelector): String

  # Action to address
  txTo(txTo: AddressSelector): Address
}

enum TronTransfersMeasureable {
  # Date
  date

  # Time
  time

  # Block
  block

  # Transaction hash
  tx_hash

  # Amount
  amount

  # Sender
  sender

  # Receiver
  receiver

  # Currency symbol
  currency_symbol

  # Token address
  currency_address

  # Token ID
  token_id

  # Token type
  token_type
}

# Selector of index of transaction in block
input TxIndexSelector {
  # Tx index is
  is: Int

  # Tx index not
  not: Int

  # Tx index in the list
  in: [Int!]

  # Tx index not in the list
  notIn: [Int!]
}

# Select transactions by subtype
input TxSubtypeSelector {
  # Transaction SubType is
  is: AlgorandTxSubType

  # Transaction SubType not
  not: AlgorandTxSubType

  # Transaction SubType in the list
  in: [AlgorandTxSubType!]

  # Transaction SubType not in the list
  notIn: [AlgorandTxSubType!]
}

# Select transactions by type
input TxTypeSelector {
  # Transaction Type is
  is: AlgorandTxType

  # Transaction Type not
  not: AlgorandTxType

  # Transaction Type in the list
  in: [AlgorandTxType!]

  # Transaction Type not in the list
  notIn: [AlgorandTxType!]
}
